<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>食用说明</title>
    <link href="/2050/10/17/%E9%A3%9F%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <url>/2050/10/17/%E9%A3%9F%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="本站食用说明"><a href="#本站食用说明" class="headerlink" title="本站食用说明"></a>本站食用说明</h1><h2 id="这是大蒟蒻CoolBall的个人博客"><a href="#这是大蒟蒻CoolBall的个人博客" class="headerlink" title="这是大蒟蒻CoolBall的个人博客"></a>这是大蒟蒻CoolBall的个人博客</h2><ol><li>这里会发一些学习笔记（比如算法、数据结构、数分）</li><li>还会有一些日常（比如本篇）</li><li>本站才刚创建，功能会慢慢补充上去，“慢慢”（数科院实在是太忙了）</li><li>欢迎各位dalao，julao，奆佬和神斧正（评论功能之后开呜呜）</li><li>禁止讨论敏感话题（dddd）</li></ol><h2 id="更新说明"><a href="#更新说明" class="headerlink" title="更新说明"></a>更新说明</h2><p>不定期更新，看心情（主要是太菜了）</p><h2 id="希望写博客可以让我学到更多和认识更多神仙！"><a href="#希望写博客可以让我学到更多和认识更多神仙！" class="headerlink" title="希望写博客可以让我学到更多和认识更多神仙！"></a>希望写博客可以让我学到更多和认识更多神仙！</h2><h2 id="感谢Enderturtle龟龟神仙让我有了建博客的想法并且给我提供帮助！"><a href="#感谢Enderturtle龟龟神仙让我有了建博客的想法并且给我提供帮助！" class="headerlink" title="感谢Enderturtle龟龟神仙让我有了建博客的想法并且给我提供帮助！"></a>感谢Enderturtle龟龟神仙让我有了建博客的想法并且给我提供帮助！</h2><p>无了，有啥之后再补充吧（</p>]]></content>
    
    
    <categories>
      
      <category>进站必读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从积性函数到莫比乌斯反演</title>
    <link href="/2022/04/01/%E4%BB%8E%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0%E5%88%B0%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    <url>/2022/04/01/%E4%BB%8E%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0%E5%88%B0%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/</url>
    
    <content type="html"><![CDATA[<h1 id="从积性函数到莫比乌斯反演"><a href="#从积性函数到莫比乌斯反演" class="headerlink" title="从积性函数到莫比乌斯反演"></a>从积性函数到莫比乌斯反演</h1><p>呜呜呜，为了数论课不做大牢，学数论！</p><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><h3 id="数论函数"><a href="#数论函数" class="headerlink" title="数论函数"></a>数论函数</h3><p>数论函数，简单来说就是定义域是$\mathbb{N^{*}}$的函数，可以视为一个数列</p><h3 id="积性函数"><a href="#积性函数" class="headerlink" title="积性函数"></a>积性函数</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>积性函数是一类特殊的数论函数，它满足以下性质<br>$$<br>\begin{aligned}<br>f(1) = 1且 对\forall i, j\in\mathbb{N^{<em>}},gcd(i,j)=1,有f(i</em>j)=f(i)<em>f(j)<br>\end{aligned}<br>$$<br>特别的，若积性函数被称为完全积性函数若它满足以下性质<br>$$<br>\forall i,j\in \mathbb{N^{</em>}},有f(i*j)=f(i)*f(j)<br>$$</p><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>设$f$,$g$为积性函数，则<br>$$<br>h(x)=f(x)*g(x)\<br>h(x)=f(x^{p})\<br>h(x)=f^{p}(x)\<br>h(x)=\sum_{d|x}f(d)g(\frac{x}{d})<br>$$<br>也为积性函数</p><p>特别的，根据唯一分解定理，设$x=\prod p_i^{k_i}$，若$F$为积性函数，则有<br>$$<br>F(x)=\prod F(p_i^{k_i})<br>$$<br>若$F$为完全积性函数，则有<br>$$<br>F(x)=\prod F^{k_i}(p_i)<br>$$</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>恒等函数$id(n) \equiv n$</p><p>单位函数$\epsilon (n)=[n=1]$</p><p>常数函数$1(n)\equiv 1$</p><p>因子和函数$\delta(n)=\sum_{d|n}d$</p><p>因子个数函数$\tau(n)=\sum_{d|n}1$</p><p>一般的，除数函数$\sigma_k(n)=\sum_{d|n}d^k$</p><p>欧拉函数$\phi(n)=\sum_{i=1}^n[gcd(i,n)=1]$，即$n$的与$n$互质的因数的个数</p><p>莫比乌斯函数，其中$n=\prod_{i=1}^r p_i^{k_i}$<br>$$<br>\mu(n)=\begin{cases}<br>1,n=1\<br>0,\exists i, s.t.k_i&gt;=2\<br>(-1)^r,otherwise<br>\end{cases}<br>$$<br>值得指出的是，上述前三个函数为完全积性函数</p><h3 id="Dirichlet-卷积"><a href="#Dirichlet-卷积" class="headerlink" title="$Dirichlet$卷积"></a>$Dirichlet$卷积</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>设$f$和$g$为数论函数，则两者的$Dirichlet$卷积$f<em>g$定义如下<br>$$<br>f</em>g(n):=\sum_{d|n}f(d)g(\frac{n}{d})<br>$$</p><h4 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h4><p>$f$,$g$,$h$为数论函数</p><h5 id="单位元存在性"><a href="#单位元存在性" class="headerlink" title="单位元存在性"></a>单位元存在性</h5><p>$\forall f, \exists \epsilon$，有$f*\epsilon \equiv f$</p><h5 id="逆元唯一性"><a href="#逆元唯一性" class="headerlink" title="逆元唯一性"></a>逆元唯一性</h5><p>若$\exists g, s.t.f*g\equiv\epsilon$，则称$g$为$f$的逆元，事实上，逆元唯一</p><h5 id="交换律"><a href="#交换律" class="headerlink" title="交换律"></a>交换律</h5><p>$f<em>g=g</em>f$</p><h5 id="结合律"><a href="#结合律" class="headerlink" title="结合律"></a>结合律</h5><p>$f*(g<em>h)=(f</em>g)*h$</p><h5 id="分配律"><a href="#分配律" class="headerlink" title="分配律"></a>分配律</h5><p>$f*(g+h)=f<em>g+f</em>h$</p><h5 id="恒等关系"><a href="#恒等关系" class="headerlink" title="恒等关系"></a>恒等关系</h5><p>$f=g\iff f<em>h=g</em>h$</p><h4 id="重要结论"><a href="#重要结论" class="headerlink" title="重要结论"></a>重要结论</h4><p><strong>1.积性函数的卷积仍为积性函数</strong></p><p><strong>2.积性函数的逆元也为积性函数</strong></p><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p>1.$\epsilon=\mu*1$</p><p>2.$\tau=1*1$</p><p>3.$\delta=id*1$</p><p><strong>4.$\phi=\mu*1$</strong></p><h2 id="数论分块"><a href="#数论分块" class="headerlink" title="数论分块"></a>数论分块</h2><p>数论分块可以用于快速求解带<strong>向下取整</strong>（显然也有整除）的和式，时间复杂度可以达到$O(\sqrt n)$</p><h3 id="两个结论"><a href="#两个结论" class="headerlink" title="两个结论"></a>两个结论</h3><p>1.$\forall a,b,c\in\mathbb{Z}, \lfloor\frac{\lfloor\frac{a}{b}\rfloor}{c}\rfloor=\lfloor\frac{a}{bc}\rfloor$</p><p>2.$\forall n\in\mathbb{N^*},|V|={\lfloor\frac{n}{d}\rfloor|\forall d, 1 \le d\le n}| \le 2\lfloor\sqrt{n}\rfloor$</p><p>所以可以枚举每个整数$d$对应的$i$的区间，来分块计算各个小区间对应的答案，最后相加就行，实现如下</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">ll <span class="hljs-title">partitioning</span><span class="hljs-params">(ll n)</span> </span>&#123;<br>    ll ans = <span class="hljs-number">0</span>;<br>    ll l, r;<br>    <span class="hljs-keyword">for</span>(l = <span class="hljs-number">1</span>; l &lt;= n; l++) &#123;<br>        r = n / (n / l);<br>        ans += <span class="hljs-number">1LL</span> * (r - l + <span class="hljs-number">1</span>) * <span class="hljs-built_in">expression</span>(l);\\expression is the formula that is to be solved<br>        l = r;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h2><p>来到了，高一集训时的噩梦，$cjq$大仙的解方程猜测$\mu$函数现场，四年来念念不忘的<strong>Mobius Inversion</strong></p><h3 id="mu-函数的补充"><a href="#mu-函数的补充" class="headerlink" title="$\mu$函数的补充"></a>$\mu$函数的补充</h3><p>$[gcd(i,j)=1]=\sum_{d|gcd(i,j)} {\mu(d)}$</p><p>即$[gcd(i,j)=1]=\epsilon *gcd(i,j)$</p><p>显然，如果$gcd(i,j)=1$，那么d只能取$1$，故和式为$1$；若不然，$gcd(i,j)$的因子总是成对出现，故可取到的$\mu$中$(-1)^r$的$r$总是连续的$1-2n$，故结果为$0$</p><h3 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h3><p>线性筛可以用于求绝大部分积性函数（其实我也不知道有什么不能求的），区别只在于在线性筛过程中对函数值的处理计算</p><p>对于$\mu$函数，实现如下</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getMu</span><span class="hljs-params">()</span> </span>&#123;<br>    mu[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    inp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= maxn; i++) &#123;<br>        <span class="hljs-keyword">if</span>(!inp[i]) prime[++tot] = i, mu[i] = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= tot &amp;&amp; i * prime[j] &lt;= maxn; j++) &#123;<br>            inp[i * prime[j]] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(i % prime[j] == <span class="hljs-number">0</span>) &#123;<br>                mu[i * p[j]] = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            mu[i * p[j]] = -mu[i];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>$f$和$g$为两个数论函数，若<br>$$<br>f(n)=\sum_{d|n}g(d)<br>$$<br>则有<br>$$<br>g(n)=\sum_{d|n}\mu(d)f(\frac{n}{d})<br>$$<br>$f$称为$g$的莫比乌斯变换，$而g$称为$f$的莫比乌斯反演，可以看出，$f = g*1$</p><p>那么，如果遇到<br>$$<br>\sum_{i=1}^n\sum_{j=1}^m [gcd(i,j)=1]<br>$$<br>就可以转化为<br>$$<br>\sum_{i=1}^n\sum_{j=1}^m\sum_{d|gcd(i,j)}{\mu(d)}<br>$$<br>改变求和顺序，可以得到<br>$$<br>\sum_{d=1}\mu(d)\sum_{i = 1}^n[d|i]\sum_{j=1}^m[d|j]<br>$$<br>显然后面两个求和号可以直接得出结果，故<br>$$<br>\sum_{i=1}^n\sum_{j=1}^m [gcd(i,j)=1]=\sum_{d=1}^{min(n,m)}\mu(d)\lfloor\frac{n}{d}\rfloor\lfloor\frac{n}{d}\rfloor<br>$$<br>直接使用数论分块解决即可</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>过几天再说（</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>莫比乌斯反演</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可持久化线段树</title>
    <link href="/2022/03/06/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <url>/2022/03/06/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="可持久化线段树学习笔记"><a href="#可持久化线段树学习笔记" class="headerlink" title="可持久化线段树学习笔记"></a>可持久化线段树学习笔记</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前写到一题区间第k大相关的题，可惜不会主席树，就现在学了一学</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>1、线段树</p><p>2、离散化</p><h2 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h2><p>可持久化线段树是维护历史版本的一个数据结构</p><p>要查询区间第k大，自然就可以想到<strong>维护$1-i$在这个区间$[l,r]$里个数</strong></p><p>为了简化问题，可以率<strong>先考虑区间$[1,k]$里的数字</strong>，随后运用<strong>前缀和</strong>解决问题</p><p>但如果每次操作都保存一棵线段树，这样子空间肯定会爆掉（</p><p>所以我们用更为优雅的方法记录历史版本</p><p>观察发现，每次操作只会更新线段树上的一条链，所以我们可以<strong>只保存一条链</strong>，并且跟原来的一整棵线段树的一部分节点构建父子关系</p><p>这样一来，就可以大大降低空间的使用了</p><p>下面来几张图解释一下建树的过程</p><p>我们以$[25957,6405,15770,26287,26465]$为例，先对他离散化，得到$[3,1,2,4,5]$</p><p>先建一棵空树</p><p><img src="/2022/03/06/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/1.PNG" alt="1"></p><p>然后添加第一个节点，也就是离散化后的$’3’$</p><p><img src="/2022/03/06/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/2.PNG" alt="2"></p><p>然后以此类推，最后的树长成这样</p><p><img src="/2022/03/06/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/6.PNG" alt="6"></p><p>不同的颜色表示了不同的操作次数</p><p>显然，我们无法使用跟普通线段树类似的堆的方法存储节点的左右孩子，所以需要另外开两个数组存储</p><p>查询时，我们只需要对左子树做差，得到一个值$x$，如果结果大于我们需要的$k$，那就从右子树继续查询，但查询的值得减去$x$；如果小于，就继续从左子树查询</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ql, <span class="hljs-keyword">int</span> qr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>, x = sum[ls[qr]] - sum[ls[ql]];<br>    <span class="hljs-keyword">if</span>(l == r) <span class="hljs-keyword">return</span> l;<br>    <span class="hljs-keyword">if</span>(k &lt;= x) <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(ls[ql], ls[qr], l, mid, k);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(rs[ql], rs[qr], mid + <span class="hljs-number">1</span>, r, k - x);<br></code></pre></div></td></tr></table></figure><p>为了实现这个数据结构，我们还需要一个数组$rt$来存储每一棵线段树的根节点的信息，也就是上图中最上面的一层。</p><p>至此，我们已经悟了主席树是个什么东西和大概怎么实现，细节部分会在下面实现的代码中呈现</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> LOG = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">int</span> n, m, len, tot;<br><span class="hljs-keyword">int</span> a[maxn], ind[maxn];<br><span class="hljs-keyword">int</span> sum[maxn * LOG], rt[maxn], ls[maxn * LOG], rs[maxn * LOG];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getid</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;val)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">lower_bound</span>(ind + <span class="hljs-number">1</span>, ind + <span class="hljs-number">1</span> + len, val) - ind;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> root = ++tot;<br>    <span class="hljs-keyword">if</span>(l == r) <span class="hljs-keyword">return</span> root;<br>    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>    ls[root] = <span class="hljs-built_in">build</span>(l, mid);<br>    rs[root] = <span class="hljs-built_in">build</span>(mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> root)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> dir = ++tot;<br>    ls[dir] = ls[root], rs[dir] = rs[root], sum[dir] = sum[root] + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(l == r) <span class="hljs-keyword">return</span> dir;<br>    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(k &lt;= mid) ls[dir] = <span class="hljs-built_in">update</span>(k, l, mid, ls[dir]);<br>    <span class="hljs-keyword">else</span> rs[dir] = <span class="hljs-built_in">update</span>(k, mid + <span class="hljs-number">1</span>, r, rs[dir]);<br>    <span class="hljs-keyword">return</span> dir;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ql, <span class="hljs-keyword">int</span> qr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>, x = sum[ls[qr]] - sum[ls[ql]];<br>    <span class="hljs-keyword">if</span>(l == r) <span class="hljs-keyword">return</span> l;<br>    <span class="hljs-keyword">if</span>(k &lt;= x) <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(ls[ql], ls[qr], l, mid, k);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(rs[ql], rs[qr], mid + <span class="hljs-number">1</span>, r, k - x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    n = <span class="hljs-built_in">read</span>(), m = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) a[i] = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">memcpy</span>(ind, a, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ind));<br>    <span class="hljs-built_in">sort</span>(ind + <span class="hljs-number">1</span>, ind + <span class="hljs-number">1</span> + n);<br>    len = <span class="hljs-built_in">unique</span>(ind + <span class="hljs-number">1</span>, ind + <span class="hljs-number">1</span> + n) - ind - <span class="hljs-number">1</span>;<br>    rt[<span class="hljs-number">0</span>] = <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, len);<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        rt[i] = <span class="hljs-built_in">update</span>(<span class="hljs-built_in">getid</span>(a[i]), <span class="hljs-number">1</span>, len, rt[i - <span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, m) &#123;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-built_in">read</span>(), r = <span class="hljs-built_in">read</span>(), k = <span class="hljs-built_in">read</span>();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ind[<span class="hljs-built_in">query</span>(rt[l - <span class="hljs-number">1</span>], rt[r], <span class="hljs-number">1</span>, len, k)]);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="空间分析"><a href="#空间分析" class="headerlink" title="空间分析"></a>空间分析</h2><p>我们一开始得先开一棵线段树，由于是动态开点，所需空间是$2n-1$，在后续的更新操作中，每次操作最多需要$\lceil logn\rceil +1$个点</p><p>综上，我们总共需要$2n-1+n(\lceil logn\rceil +1)$个点，瞎估估就是$n(3+ \lceil logn\rceil)$个节点</p><h2 id="时间分析"><a href="#时间分析" class="headerlink" title="时间分析"></a>时间分析</h2><p>我们开一棵空树需要的时间是$O(logn)$，每次更新和查询的时间开销也是$O(logn)$的，对于m次查询，总共的时间复杂度就是$O(mlogn)$的</p><p>还是非常优秀的</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>上面是我学习完主席树后的一点笔记，如果您发现了任何问题，请在下面评论直接告诉我（评论期望近期开放）</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模板</tag>
      
      <tag>可持久化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DeterminantCalculator</title>
    <link href="/2021/11/05/DeterminantCalculator/"/>
    <url>/2021/11/05/DeterminantCalculator/</url>
    
    <content type="html"><![CDATA[<p>行列式太难算了</p><p>网上计算器也没过程</p><p>整了一个</p><p>非常丑</p><p>但无所谓了（</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxm 6005</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxn 1010</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inf 2147483647</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxw 13000</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, b) for(int i = a; i &lt;= b; i++)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> loop(i, a, b) for(int i = a; i &gt;= b; i--)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> sqr(x) ((x) * (x))</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    ll s = <span class="hljs-number">0</span>, w = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">char</span> ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;-&#x27;</span>) w = <span class="hljs-number">-1</span>; ch = <span class="hljs-built_in">getchar</span>();&#125;<br>    <span class="hljs-keyword">while</span>(ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;s = s * <span class="hljs-number">10</span> + ch - <span class="hljs-string">&#x27;0&#x27;</span>; ch = <span class="hljs-built_in">getchar</span>();&#125;<br>    <span class="hljs-keyword">return</span> s * w;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* ============================================================================</span><br><span class="hljs-comment">@Author:      Cool_Ball</span><br><span class="hljs-comment">@DateTime:    2021-11-04 21:03:38</span><br><span class="hljs-comment">* ============================================================================</span><br><span class="hljs-comment">*/</span><br><br>ll n;<br><br><span class="hljs-comment">//----------fraction start----------//</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">frac</span> &#123;</span><br>    ll up, down;<br>&#125;;<br><br><span class="hljs-function">ll <span class="hljs-title">gcd</span><span class="hljs-params">(ll a, ll b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">gcd</span>(b, a % b);<br>&#125;<br><br><span class="hljs-function">frac <span class="hljs-title">add</span><span class="hljs-params">(frac a, frac b)</span> </span>&#123;<br>    ll tmp1 = a.down * b.down, tmp2 = a.up * b.down + b.up * a.down;<br>    ll g = <span class="hljs-built_in">gcd</span>(tmp1, tmp2);<br>    tmp1 /= g, tmp2 /= g;<br>    <span class="hljs-keyword">return</span> frac&#123;tmp2, tmp1&#125;;<br>&#125;<br><br><span class="hljs-function">frac <span class="hljs-title">subt</span><span class="hljs-params">(frac a, frac b)</span> </span>&#123;<br>    ll tmp1 = a.down * b.down, tmp2 = a.up * b.down - b.up * a.down;<br>    ll g = <span class="hljs-built_in">gcd</span>(tmp1, tmp2);<br>    tmp1 /= g, tmp2 /= g;<br>    <span class="hljs-keyword">if</span>(tmp1 &lt; <span class="hljs-number">0</span>) &#123;<br>        tmp1 = <span class="hljs-built_in">abs</span>(tmp1);<br>        tmp2 = -tmp2;<br>    &#125;<br>    <span class="hljs-keyword">return</span> frac&#123;tmp2, tmp1&#125;;<br>&#125;<br><br><span class="hljs-function">frac <span class="hljs-title">mul</span><span class="hljs-params">(frac a, frac b)</span> </span>&#123;<br>    ll tmp1 = a.down * b.down, tmp2 = a.up * b.up;<br>    ll g = <span class="hljs-built_in">gcd</span>(tmp1, tmp2);<br>    tmp1 /= g, tmp2 /= g;<br>    <span class="hljs-keyword">return</span> frac&#123;tmp2, tmp1&#125;;<br>&#125;<br><br><span class="hljs-function">frac <span class="hljs-title">div</span><span class="hljs-params">(frac a, frac b)</span> </span>&#123;<br>    ll tmp1 = a.down * b.up, tmp2 = a.up * b.down;<br>    ll g = <span class="hljs-built_in">gcd</span>(tmp1, tmp2);<br>    tmp1 /= g, tmp2 /= g;<br>    <span class="hljs-keyword">return</span> frac&#123;tmp2, tmp1&#125;;<br>&#125;<br><span class="hljs-comment">//----------fraction end----------//</span><br><br><br><span class="hljs-comment">//----------Guass Elimination start----------//</span><br>frac A[maxn][maxn];<br>ll exc = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Guass</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        <span class="hljs-comment">//find largest pivot</span><br>        ll maxx = i;<br>        <span class="hljs-built_in">rep</span>(j, i + <span class="hljs-number">1</span>, n) &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(A[j][i].up * A[maxx][i].down) &gt; <span class="hljs-built_in">abs</span>(A[maxx][i].up * A[j][i].down)) &#123;<br>                maxx = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//row exhange</span><br>        <span class="hljs-keyword">if</span>(maxx != i) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;Switch the &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;-th row with the &quot;</span> &lt;&lt; maxx &lt;&lt; <span class="hljs-string">&quot;-th row&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-built_in">rep</span>(j, <span class="hljs-number">1</span>, n) &#123;<br>                <span class="hljs-built_in">swap</span>(A[i][j], A[maxx][j]);<br>            &#125;<br>            exc++;<br>            <span class="hljs-built_in">rep</span>(o, <span class="hljs-number">1</span>, n) &#123;<br>                <span class="hljs-built_in">rep</span>(p, <span class="hljs-number">1</span>, n) &#123;<br>                    cout &lt;&lt; A[o][p].up;<br>                    <span class="hljs-keyword">if</span>(A[o][p].down != <span class="hljs-number">1</span>) cout &lt;&lt; <span class="hljs-string">&quot;/&quot;</span> &lt;&lt; A[o][p].down;<br>                    cout &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>                &#125;<br>                cout &lt;&lt; endl;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//Guass eliminated to upper triangular matrix</span><br>        <span class="hljs-built_in">rep</span>(j, i + <span class="hljs-number">1</span>, n) &#123;<br>            frac tmp = <span class="hljs-built_in">div</span>(A[j][i] ,A[i][i]);<br>            cout &lt;&lt; <span class="hljs-string">&quot;Subtract the &quot;</span> &lt;&lt; j &lt;&lt; <span class="hljs-string">&quot;-th row with &quot;</span> &lt;&lt; tmp.up &lt;&lt; <span class="hljs-string">&quot;/&quot;</span> &lt;&lt; tmp.down &lt;&lt; <span class="hljs-string">&quot; times of the &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;-th row.&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-built_in">rep</span>(k, i , n) &#123;<br>                A[j][k] = <span class="hljs-built_in">subt</span>(A[j][k], <span class="hljs-built_in">mul</span>(A[i][k], tmp));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i &lt; n) &#123;<br>            <span class="hljs-built_in">rep</span>(o, <span class="hljs-number">1</span>, n) &#123;<br>                <span class="hljs-built_in">rep</span>(p, <span class="hljs-number">1</span>, n) &#123;<br>                    cout &lt;&lt; A[o][p].up;<br>                    <span class="hljs-keyword">if</span>(A[o][p].down != <span class="hljs-number">1</span>) cout &lt;&lt; <span class="hljs-string">&quot;/&quot;</span> &lt;&lt; A[o][p].down;<br>                    cout &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>                &#125;<br>                cout &lt;&lt; endl;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//output the determianat of the martix</span><br>    frac ans = frac&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        ans = <span class="hljs-built_in">mul</span>(ans, A[i][i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The determinant of the matrix is:\n&quot;</span>);<br>    <span class="hljs-keyword">if</span>(exc % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &amp;&amp; ans.up != <span class="hljs-number">0</span>) cout &lt;&lt; <span class="hljs-string">&quot;-&quot;</span>;<br>    cout &lt;&lt; ans.up;<br>    <span class="hljs-keyword">if</span>(ans.down != <span class="hljs-number">1</span>) cout &lt;&lt; <span class="hljs-string">&quot;/&quot;</span> &lt;&lt; ans.down &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//----------Guass Elimination end----------//</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inp</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Please input the matrix(integer or fraction)\n&quot;</span>);<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        <span class="hljs-built_in">rep</span>(j, <span class="hljs-number">1</span>, n) &#123;<br>            <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>;<br>            string s;<br>            cin &gt;&gt; s;<br>            ll num = <span class="hljs-number">0</span>, w = <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">rep</span>(k, <span class="hljs-number">0</span>, s.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">if</span>(s[k] == <span class="hljs-string">&#x27;/&#x27;</span>) &#123;<br>                    flag = <span class="hljs-literal">true</span>;<br>                    A[i][j].up = w * num;<br>                    w = <span class="hljs-number">1</span>, num = <span class="hljs-number">0</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(s[k] == <span class="hljs-string">&#x27;-&#x27;</span>) w = <span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">if</span>(s[k] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[k] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) num = num * <span class="hljs-number">10</span> + s[k] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag) A[i][j].down = w * num;<br>            <span class="hljs-keyword">else</span> &#123;<br>                A[i][j].up = w * num;<br>                A[i][j].down = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Please input the matrix size(n*n)\n&quot;</span>);<br>    n = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">inp</span>();<br>    <span class="hljs-built_in">Guass</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>行列式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拉格朗日插值法</title>
    <link href="/2021/10/21/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E6%B3%95/"/>
    <url>/2021/10/21/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="中国剩余定理和Lagrange插值法"><a href="#中国剩余定理和Lagrange插值法" class="headerlink" title="中国剩余定理和Lagrange插值法"></a>中国剩余定理和Lagrange插值法</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>很巧，高代课讲到了Lagrange插值法，凭着“上课听不明白只好下课自己搞”的意志，我学学证明顺带来写个板子。</p><h2 id="前置知识：中国剩余定理（CRT）"><a href="#前置知识：中国剩余定理（CRT）" class="headerlink" title="前置知识：中国剩余定理（CRT）"></a>前置知识：中国剩余定理（CRT）</h2><p>中国剩余定理是用来求解形如<br>$$<br>\begin{cases}<br>x &amp; \equiv  a_1 (mod \quad m_1) \<br>x &amp; \equiv  a_2 (mod \quad m_2) \<br>&amp;…… \<br>x &amp; \equiv  a_k (mod \quad m_k)<br>\end{cases}<br>$$<br>的线性同余方程组的解的。其中，$\forall i\neq j \quad (a_i, a_j)=1$，我们需要找出最小的非负整数解$x$。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>设$M=\prod_{i=0}^k m_i$,$M_i=\frac{M}{m_i}$,$M_iT_i \equiv 1(mod \ m_i)$，其中$1\leq i,j \leq n$。</p><p>故可以构造一个解$x=\sum_{i=1}^na_iM_it_i$</p><p>由此，可以求出任意解$x_0=x+k*M$</p><p>**最小正整数解$X$**即为$x_0%M$</p><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>显然，在第$i$个同余方程里，$a_jM_jt_j \equiv 0(mod \ m_i)$</p><p>$a_iM_it_i \equiv a_i(mod \ m_i)$</p><p>所以$\forall i,X \equiv a_i (mod \ m_i)$，满足题意。</p><h3 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h3><p>若$a*a^{-1} \equiv 1 (mod \ p)$，则称$a^{-1}$是$a$在$mod \ p$意义下的逆元。</p><p>用扩展欧几里得$(exgcd)$来求解</p><p>过程如下：</p><p>$$<br>因为a<em>x+b</em>y=(a, b)\<br>且b*x’+(a%b)<em>y’=(b,a%b)\<br>a%b=a-\lfloor\frac{a}{b}\rfloor</em>b<br>$$</p><p>$$<br>有a<em>y’+b</em>(x’-\lfloor\frac{a}{b}\rfloor<em>y’)=(a,b)\<br>故x=y’,y=(x’-\lfloor\frac{a}{b}\rfloor</em>y’)<br>$$</p><p>显然，$(M_i, m_i)=1$，故令$a=M_i, b=m_i$，则$M_ix+m_iy=1$，故$M_ix=1-m_iy$，可得$x$为$M_i$在$mod\ m_i$下的逆元，即为题设所求。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">ll n, a[maxn], m[maxn], Mi[maxn], M = <span class="hljs-number">1</span>, X;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(ll a, ll b, ll &amp;x, ll &amp;y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>) &#123;x = <span class="hljs-number">1</span>; y = <span class="hljs-number">0</span>; <span class="hljs-keyword">return</span>;&#125;<br>    <span class="hljs-built_in">exgcd</span>(b, a % b, x, y);<br>    ll z = x;<br>    x = y, y = z - y * (a / b);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CRT</span><span class="hljs-params">()</span> </span>&#123;<br>    n = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        m[i] = <span class="hljs-built_in">read</span>(), a[i] = <span class="hljs-built_in">read</span>();<br>        M *= m[i];<br>    &#125;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        Mi[i] = M / m[i];<br>        ll x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">exgcd</span>(Mi[i], m[i], x, y);<br>        X += a[i] * Mi[i] * (x &lt; <span class="hljs-number">0</span> ? (x + m[i]):x);<br>    &#125;<br>    cout &lt;&lt; X % M &lt;&lt; endl;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="正片：Lagrange插值"><a href="#正片：Lagrange插值" class="headerlink" title="正片：Lagrange插值"></a>正片：Lagrange插值</h2><h3 id="多项式储备知识（多项式余数）"><a href="#多项式储备知识（多项式余数）" class="headerlink" title="多项式储备知识（多项式余数）"></a>多项式储备知识（多项式余数）</h3><p>已知多项式<br>$$<br>f(x)\in P[x],f(x)=\sum_{i=0}^{n}a_ix^i<br>$$</p><p>$$<br>故f(x)%(x-\alpha)=\sum_{i=0}^{n}a_i\alpha^i<br>$$</p><p>下证：</p><p>已知<br>$$<br>f(x)=\sum_{i=0}^{n}a_ix^i \<br>f(x)=\sum_{i=0}^{n}a_ix^i=\sum_{i=0}^{n}(x-\alpha+\alpha)^i=\sum_{i=0}^{n}a_i\sum_{j=0}^{i}{i \choose j}(x-\alpha)^j\alpha^{i-j}<br>$$</p><p>可知，当$j\neq0$时，该子项$p%(x-\alpha)=0$恒成立<br>故余数必为$j=0$的项之和，即<br>$$<br>\begin{aligned}<br>r(x)=\sum_{i=0}^{n}a_i\alpha^i<br>\end{aligned}<br>$$</p><h3 id="模意义下的推导过程"><a href="#模意义下的推导过程" class="headerlink" title="模意义下的推导过程"></a>模意义下的推导过程</h3><p>由上述可以得到一个关于$f(x)$的同余方程组，即<br>$$<br>\begin{cases}<br>f(x) &amp; \equiv  y_1 (mod \ (x-x_1)) \<br>f(x) &amp; \equiv  y_2 (mod \ (x-x_2)) \<br>&amp;…… \<br>f(x) &amp; \equiv  y_n (mod \ (x-x_n))<br>\end{cases}<br>$$<br>根据<strong>中国剩余定理</strong><br>$$<br>\begin{aligned}M=\prod_{i=1}^{n}(x-x_i),M_i=\frac{M}{x-x_i}=\prod_{j\neq i}(x-x_j)\end{aligned}<br>$$<br>得$M_i$在$mod(x-x_i)$意义下的逆元$T_i$为<br>$$<br>\begin{aligned}M_i^{-1}=T_i=\prod_{j\neq i}\frac{1}{x_i-x_j}\end{aligned}<br>$$<br>故有<br>$$<br>\begin{aligned}<br>f(x) \equiv \sum_{i=1}^{n}y_iM_iT_i\equiv \sum_{i=1}^{n}y_i\prod_{j\neq i}M_iT_i\equiv \sum_{i=1}^{n}y_i\prod_{j\neq i}\frac{x-x_i}{x_i-x_j} \quad mod(M)<br>\end{aligned}<br>$$</p><p>又$f(x)$唯一，故<br>$$<br>\begin{aligned}<br>f(x) = \sum_{i=1}^{n}y_i\prod_{j\neq i}\frac{x-x_i}{x_i-x_j}<br>\end{aligned}<br>$$<br>即为Lagrange插值的表达式</p><h3 id="通常意义下的推导过程"><a href="#通常意义下的推导过程" class="headerlink" title="通常意义下的推导过程"></a>通常意义下的推导过程</h3><p>已知$f(x)$过$n$个点$P_1(x_1,y_1),P_2(x_2,y_2),…,P_n(x_n,y_n)$，以及其在$x$轴上的投影$P_i^{‘}(x_i,0)$</p><p>考虑构造$n$个函数$F_i(x)$使得其过点，<br>$$<br>\left{<br>\begin{aligned}<br>&amp; P_j^{‘} \quad j\neq i \<br>&amp; P_i \quad j=i<br>\end{aligned}<br>\right.<br>$$<br>则可知所需函数$f(x)=\sum_{i=1}^{n}F_i(x)$.</p><p>则可设$F_i(x)=a\prod_{j\neq i}(x_i-x_j)$，将$P_i$代入可得$a=\frac{y_i}{\prod_{j\neq i}(x_i-x_j)}$，所以<br>$$<br>\begin{aligned}F_i(x)=y_i\prod_{j\neq i}\frac{x-x_j}{x_i-x_j}\end{aligned}<br>$$<br>由此导出<strong>Lagrange插值在通常意义下的公式</strong>，如下<br>$$<br>\begin{aligned}f(x)=\sum_{i=1}^{n}F_i(x)=\sum_{i=1}^{n}y_i\prod_{j\neq i}\frac{x-x_j}{x_i-x_j}\end{aligned}<br>$$<br>与上述<strong>在模意义下的Lagrange插值公式</strong>相同</p><h2 id="代码实现（对-x-k-时，即需要求-f-k-的值的代码）"><a href="#代码实现（对-x-k-时，即需要求-f-k-的值的代码）" class="headerlink" title="代码实现（对$x=k$时，即需要求$f(k)$的值的代码）"></a>代码实现（对$x=k$时，即需要求$f(k)$的值的代码）</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> ll p = <span class="hljs-number">998244353</span>;<br>ll n, y[maxn], x[maxn], k;<br>ll ans, s1, s2;<br><br><span class="hljs-function">ll <span class="hljs-title">fastmod</span><span class="hljs-params">(ll a, ll k)</span> </span>&#123;<br>    ll base = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(k) &#123;<br>        <span class="hljs-keyword">if</span>(k &amp; <span class="hljs-number">1</span>) base = base * a % p;<br>        a = a * a % p;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> base % p;<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">inv</span><span class="hljs-params">(ll x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">fastmod</span>(x, p - <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Lagrange</span><span class="hljs-params">()</span> </span>&#123;<br>    n = <span class="hljs-built_in">read</span>(), k = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        x[i] = <span class="hljs-built_in">read</span>(), y[i] = <span class="hljs-built_in">read</span>();<br>    &#125;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        s1 = y[i] % p;<br>        s2 = <span class="hljs-number">1LL</span>;<br>        <span class="hljs-built_in">rep</span>(j, <span class="hljs-number">1</span>, n) &#123;<br>            <span class="hljs-keyword">if</span>(i != j) &#123;<br>                s1 = s1 * (k - x[j]) % p;<br>                s2 = s2 * (x[i]-x[j]) % p;<br>            &#125;<br>        &#125;<br>        ans += s1 * <span class="hljs-built_in">inv</span>(s2) % p;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, (ans % p + p) % p);<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>多项式</tag>
      
      <tag>扩展欧几里得</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>伯努利数</title>
    <link href="/2021/10/17/%E4%BC%AF%E5%8A%AA%E5%88%A9%E6%95%B0/"/>
    <url>/2021/10/17/%E4%BC%AF%E5%8A%AA%E5%88%A9%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="伯努利数"><a href="#伯努利数" class="headerlink" title="伯努利数"></a>伯努利数</h1><p>今天看吉米多维奇的时候偶然看到伯努利数，一查oi-wiki上也有，就学了一下，就当第一篇博客了。（之后会写FFT和NTT，多项式求逆和多项式除法的）</p><h2 id="背景：等幂求和"><a href="#背景：等幂求和" class="headerlink" title="背景：等幂求和"></a>背景：等幂求和</h2><p>$$<br>\begin{aligned}\sum_{k=0}^{n-1}k^m=\frac{1}{m+1}\sum_{k=0}^mC_{m+1}^kB_kn^{m+1-k}\end{aligned}<br>$$</p><p>利用$(k+1)^2-k^2=2k+1$可得<br>$$<br>\begin{aligned}\sum_{k=1}^n[(k+1)^2-k^2]=\sum_{k=1}^n(2k+1)\end{aligned}<br>$$<br>整理后即为<br>$$<br>\begin{aligned}\sum_{k=1}^nk=\frac{n(n+1)}{2}\end{aligned}<br>$$<br>类似的，利用$(k+1)^3-k^3=3k^2+3k+1$可得<br>$$<br>\begin{aligned}\sum_{k=1}^n[(k+1)^3-k^3]=\sum_{k=1}^n(3k^2+3k+1)=3\sum_{k=1}^nk^2+3\sum_{k=1}^nk+n\end{aligned}<br>$$</p><p>$$<br>\begin{aligned}=3\sum_{k=1}^nk^2+\frac{3n(n+1)}{2}+n\end{aligned}<br>$$</p><p>整理后即为<br>$$<br>\begin{aligned}\sum_{k=1}^nk^2=\frac{n(n+1)(2n+1)}{6}\end{aligned}<br>$$<br>继续下去可得<br>$$<br>\begin{aligned}\sum_{k=1}^nk^3=[\frac{n(n+1)}{2}]^2\end{aligned}<br>$$<br>由此，伯努利得到了$\sum_{k=0}^{n-1}k^m$的通项，如上文。</p><h2 id="一个优美的性质"><a href="#一个优美的性质" class="headerlink" title="一个优美的性质"></a>一个优美的性质</h2><p>令公式中的$n=1$可得<br>$$<br>\begin{aligned}0=\frac{1}{m+1}\sum_{k=0}^mC_{m+1}^kB_k\end{aligned}<br>$$<br>即<br>$$<br>\begin{aligned}\sum_{k=0}^mC_{m+1}^kB_k=0\end{aligned}<br>$$</p><h2 id="证明（咕咕咕）"><a href="#证明（咕咕咕）" class="headerlink" title="证明（咕咕咕）"></a>证明（咕咕咕）</h2><h3 id="方法1：归纳法"><a href="#方法1：归纳法" class="headerlink" title="方法1：归纳法"></a>方法1：归纳法</h3><h3 id="方法2：生成函数"><a href="#方法2：生成函数" class="headerlink" title="方法2：生成函数"></a>方法2：生成函数</h3>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组合数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
