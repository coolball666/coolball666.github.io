<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>食用说明</title>
    <link href="/2050/10/17/%E9%A3%9F%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <url>/2050/10/17/%E9%A3%9F%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="本站食用说明">本站食用说明</h1><h2 id="这是大蒟蒻coolball的个人博客">这是大蒟蒻CoolBall的个人博客</h2><ol type="1"><li>这里会发一些学习笔记（比如算法、数据结构、数分）</li><li>还会有一些日常（比如本篇）</li><li>本站才刚创建，功能会慢慢补充上去，“慢慢”（数科院实在是太忙了）</li><li>欢迎各位dalao，julao，奆佬和神斧正（评论功能之后开呜呜）</li><li>禁止讨论敏感话题（dddd）</li></ol><h2 id="更新说明">更新说明</h2><p>不定期更新，看心情（主要是太菜了）</p><h2 id="希望写博客可以让我学到更多和认识更多神仙">希望写博客可以让我学到更多和认识更多神仙！</h2><h2 id="感谢enderturtle龟龟神仙让我有了建博客的想法并且给我提供帮助">感谢Enderturtle龟龟神仙让我有了建博客的想法并且给我提供帮助！</h2><p>无了，有啥之后再补充吧（</p>]]></content>
    
    
    <categories>
      
      <category>进站必读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生成函数大杂烩</title>
    <link href="/2022/10/05/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    <url>/2022/10/05/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="生成函数">生成函数</h1><p>大家都知道，生成函数是一类求解数列的方法。基本思想就是把数列<span class="math inline">\({a_n}\)</span>作为幂级数<span class="math inline">\(\sum\limits_{n=0}^{\infty}a_nx^n\triangleq f(x)\)</span>的系数，得到有关<span class="math inline">\(f(x)\)</span>的关系式，然后求得<span class="math inline">\(f(x)\)</span>的解析表达式，从而再进一步使用幂级数展开求得<span class="math inline">\({a_n}\)</span>的表达式的方法。</p><p>需要特地指出的是，上述有关级数的收敛问题，都是被一种称为<strong>形式收敛</strong>的理论系统严格解决的。也就是说不考虑<span class="math inline">\(x\)</span>的定义域问题。</p><p>通常而言，会对递推数列使用生成函数进行求解。</p><p>生产函数通常分为普通生成函数，指数生成函数和狄利克雷生成函数三类，接下来会一一进行讨论。</p><h2 id="普通生成函数">普通生成函数</h2><p>最一般的生成函数，我们定义 <span class="math display">\[f(x)=\sum_{n=0}^{\infty}a_nx^n\]</span> 在这个定义下，组合数<span class="math inline">\(a_k= {n\choose k}\)</span>可以得到一个很好的生成函数<span class="math inline">\(f(x)=(1+x)^n\)</span>.</p><p>值得指出的是，<span class="math inline">\(\{1\}\)</span>的普通生成函数是<span class="math inline">\(f(x)=\frac{1}{1-x}\)</span></p><h3 id="一些运算性质">一些运算性质</h3><p>我们设<span class="math inline">\(f(x),g(x)\)</span>为<span class="math inline">\(\{a_n\},\{b_n\}\)</span>的普通生成函数</p><h4 id="加法">加法</h4><p>显然<span class="math inline">\(f(x)+g(x)\)</span>是<span class="math inline">\(\{a_n+b_n\}\)</span>的普通生成函数</p><h4 id="乘法卷积">乘法（卷积）</h4><p><span class="math display">\[f(x)g(x)=(\sum_{n=0}^{\infty}a_nx^n)(\sum_{n=0}^{\infty}b_nx^n)=\sum_{n=0}^{\infty}x^n(\sum_{k=0}^{n}a_kb_{n-k})\]</span></p><p>从而<span class="math inline">\(f(x)g(x)\)</span>是<span class="math inline">\(\{\sum\limits_{k=0}^{n}a_kb_{n-k}\}=a\star b\)</span>的生成函数</p><h4 id="数列乘法">数列乘法</h4><p>若<span class="math inline">\(P(x)\)</span>为一多项式函数，则<span class="math inline">\({P(n)a_n}\)</span>的普通生成函数为<span class="math inline">\(P(xD)f\)</span>，其中<span class="math inline">\(xD\)</span>为<span class="math inline">\(x\frac{d}{dx}\)</span>这个运算</p><p>特殊的<span class="math inline">\({na_n}\)</span>的普通生成函数为<span class="math inline">\(xDf\)</span></p><h3 id="catalan数">Catalan数</h3><p>Catalan数是一个使用生成函数可以解决的经典例子。因为生成函数的基本思想比较容易理解，所以使用一些例子来熟悉一下。</p><p>先给出Catalan数<span class="math inline">\(C_n\)</span>的递推定义 <span class="math display">\[C_n=\sum_{k=1}^nC_{k-1}C_{n-k}\\C_0=1\]</span> 所以我们定义<span class="math inline">\(f(x)=\sum\limits_{n=0}^{\infty}C_nx^n\)</span></p><p>从而可以得到 <span class="math display">\[\begin{aligned}f(x)-C_0&amp;=\sum_{n=1}^{\infty}C_nx^n=\sum_{n=1}^{\infty}(\sum_{k=1}^{n}C_{k-1}C_{n-k})x^n=\sum_{k=1}^{\infty}\sum_{n=k}^{\infty}C_{k-1}C_{n-k}x^n\\&amp;=\sum_{k=1}^{\infty}C_{k-1}x^k\sum_{n=k}^{\infty}C_{n-k}x^{n-k}=xf^2(x)\end{aligned}\]</span> 所以我们得到<span class="math inline">\(xf^2(x)-f(x)+1=0\)</span>，从而<span class="math inline">\(f(x)=\frac{1\pm\sqrt{1-4x}}{2x}\)</span>，又<span class="math inline">\(f(x)=C_0=0\)</span>，所以取负号</p><p>得到 <span class="math display">\[f(x)=\frac{1-\sqrt{1-4x}}{2x}=\frac{1-\sum\limits_{n=0}^{\infty}{\frac{1}{2} \choose n}(-4)^nx^n}{2x}=-\frac{1}{2}\sum_{n=1}^{\infty}{\frac{1}{2} \choose n}(-4)^nx^{n-1}=-\frac{1}{2}\sum_{n=0}^{\infty}{\frac{1}{2} \choose n+1}(-4)^{n+1}x^n\]</span></p><p>从而可知 <span class="math display">\[C_n=-\frac{1}{2}{\frac{1}{2} \choose n+1}(-4)^{n+1}=-\frac{1}{2}\frac{(-1)^n(2n)!!}{2^{n}(n+1)!}(-4)^{n+1}=\frac{2n \choose n}{n+1}\\\]</span></p><p>从上面的例子，我们可以看出使用普通生成函数求解数列的一般方法。这个方法是容易理解的，只是如何使用正确的变换来得到关于<span class="math inline">\(f(x)\)</span>的关系是需要一定技巧的，也是有一定难度的。</p><p>正如在前面提到的，组合数的生成函数十分的优美简洁，所以普通生成函数跟<strong>组合</strong>类的计数问题有密不可分的联系。下面介绍一类经典的使用普通生成函数计数的组合类型的问题。</p><h3 id="典中典1">典中典1</h3><p>给出一个命题：</p><p><strong>从<span class="math inline">\(n\)</span>元集<span class="math inline">\(S=\{S_1,S_2,\cdots,S_n\}\)</span>中选取<span class="math inline">\(k\)</span>个元的组合数为<span class="math inline">\(a_k\)</span>，其中要求<span class="math inline">\(S_i\)</span>出现的次数集为<span class="math inline">\(M_i(1\leq i\leq n)\)</span>，则<span class="math inline">\(\{a_k\}\)</span>的生成函数<span class="math inline">\(\sum\limits_{k=0}^{\infty}a_kx^k=\prod\limits_{i=1}^{n}\sum\limits_{m\in M_i}x^m\)</span></strong></p><p>证明：考虑等式右边<span class="math inline">\(\prod\limits_{i=1}^{n}\sum\limits_{m\in M_i}x^m\)</span>的展开式中<span class="math inline">\(x^{m_1}x^{m_2}\cdots x^{m_n}=x^{m_1+m_2+\cdots +m_n}\)</span>项的系数，可以看出<span class="math inline">\(x^k\)</span>前面的系数即为<span class="math inline">\(m_1+m_2+\cdots +m_n=k\)</span>的解的个数，其中<span class="math inline">\(m_i\in M_i\)</span></p><p>这类问题有一个经典的具体问题，如下</p><h4 id="一个例子">一个例子</h4><p>从数量不限的苹果、香蕉、橘子和梨中，选取<span class="math inline">\(n\)</span>个水果装成一袋，且选取的苹果数是偶数，香蕉数是5的倍数，橘子至多有4个，梨至多有1个。这样的装法共有多少种？</p><h5 id="解">解</h5><p>就是上述命题的运用，可以看出<span class="math inline">\(M_1=\{0,2,4,\cdots\},M_2=\{0,5,10,\cdots\},M_3=\{0,1,2,3,4\},M_4=\{0,1\}\)</span></p><p>所以可以得到生成函数<span class="math inline">\(f(x)=(1+x^2+x^4+\cdots)(1+x^5+x^{10}+\cdots)(1+x+x^2+x^3+x^4)(1+x)=\frac{1}{(1-x)^2}\)</span>,所以所求数列<span class="math inline">\(a_n=(-1)^n{-2 \choose n}={n+2-1 \choose n}={n+1 \choose 1}=n+1\)</span></p><p>可以看出这类问题中选取元素的顺序对答案是没有影响的，是一类组合问题</p><h2 id="指数生成函数">指数生成函数</h2><p>对于普通生成函数，组合数可以得到一个优美简洁的函数，但对于另一个重要的计数数列，排列数，似乎就十分的复杂。所以引入一个指数生成函数，使用指数生成函数，排列数也可以得到一个优美简洁的结果。</p><p>首先给出定义，如下 <span class="math display">\[f(x)=\sum_{n=0}^{\infty}\frac{a_n}{n!}x^n\]</span> 我们考虑<span class="math inline">\(a_k=(n)_k=A_n^k\)</span>，可以得到它的指数生成函数为<span class="math inline">\(f(x)=\sum\limits_{k=0}^n(n)_k\frac{x^k}{k!}=\sum\limits_{k=0}^n{n \choose k}x^k=(1+x)^n\)</span></p><p>我们发现，结果确实十分优雅。</p><p>至于他为什么叫指数生成函数，我们考虑数列<span class="math inline">\(a_n=1\)</span>，可以得到<span class="math inline">\(f(x)=\sum\limits_{n=0}^{\infty}\frac{x^n}{n!}=e^x\)</span>，得到的是指数函数，所以被称为指数生成函数。</p><p>类似的我们举一个例子来熟悉指数生成函数的计算过程</p><h3 id="一些运算性质-1">一些运算性质</h3><p>我们设<span class="math inline">\(f(x),g(x)\)</span>为<span class="math inline">\(\{a_n\},\{b_n\}\)</span>的指数生成函数</p><h4 id="加法-1">加法</h4><p>显然<span class="math inline">\(f(x)+g(x)\)</span>是<span class="math inline">\(\{a_n+b_n\}\)</span>的生成函数</p><h4 id="乘法">乘法</h4><p><span class="math display">\[f(x)g(x)=(\sum_{n=0}^{\infty}a_n\frac{x^n}{n!})(\sum_{n=0}^{\infty}b_n\frac{x^n}{n!})=\sum_{n=0}^{\infty}\frac{x^n}{n!}(\sum_{k=0}^{n}\frac{n!}{k!(n-k)!}a_kb_{n-k})=\sum_{n=0}^{\infty}\frac{x^n}{n!}(\sum_{k=0}^{n}{n \choose k}a_kb_{n-k})\]</span></p><p>从而<span class="math inline">\(f(x)g(x)\)</span>是<span class="math inline">\(\{\sum\limits_{k=0}^{n}{n \choose k}a_kb_{n-k}\}\)</span>的生成函数</p><h4 id="数列乘法-1">数列乘法</h4><p>若<span class="math inline">\(P(x)\)</span>为一多项式函数，则<span class="math inline">\({P(n)a_n}\)</span>的普通生成函数为<span class="math inline">\(P(xD)f\)</span>，其中<span class="math inline">\(xD\)</span>为<span class="math inline">\(x\frac{d}{dx}\)</span>这个运算</p><p>特殊的<span class="math inline">\({na_n}\)</span>的普通生成函数为<span class="math inline">\(xDf\)</span></p><h3 id="bell数">Bell数</h3><p>首先给出Bell数的递推定义 <span class="math display">\[B_n=\sum_{k=1}^{n}{n-1 \choose k-1}B_{n-k}\\B_0=B_1=1\]</span> 所以我们可以定义它的指数生成函数<span class="math inline">\(f(x)=\sum\limits_{n=0}^{\infty}B_n\frac{x^n}{n!}\)</span>,得到 <span class="math display">\[\begin{aligned}f(x)&amp;=\sum_{n=0}^{\infty}B_n\frac{x^n}{n!}=B_0+\sum_{n=1}^{\infty}B_n\frac{x^n}{n!}=B_0+\sum_{n=1}^{\infty}\sum_{k=1}^{n}{n-1 \choose k-1}B_{n-k}\frac{x^n}{n!}\\&amp;=B_0+\sum_{n=1}^{\infty}\sum_{k=1}^{n}x^k\frac{B_{n-k}}{n(k-1)!(n-k)!}x^{n-k}=B_0+\sum_{k=1}^{\infty}\frac{x^k}{(k-1)!}\sum_{n=k}^{\infty}\frac{B_{n-k}}{n(n-k)!}x^{n-k}\end{aligned}\]</span> 我们发现如果能把分母上的<span class="math inline">\(n\)</span>去掉，就可以得到关于<span class="math inline">\(f(x)\)</span>的关系式了，如果对原本的式子求导，就可以去掉<span class="math inline">\(n\)</span>，所以我们现在考虑对生成函数求导，得到 <span class="math display">\[\begin{aligned}f‘(x)&amp;=\sum_{n=1}^{\infty}B_n\frac{x^{n-1}}{(n-1)!}=\sum_{n=1}^{\infty}\sum_{k=1}^{n}{n-1 \choose k-1}B_{n-k}\frac{x^{n-1}}{(n-1)!}\\&amp;=\sum_{n=1}^{\infty}\sum_{k=1}^{n}x^{k-1}\frac{B_{n-k}}{(k-1)!(n-k)!}x^{n-k}=\sum_{k=1}^{\infty}\frac{x^{k-1}}{(k-1)!}\sum_{n=k}^{\infty}\frac{B_{n-k}}{(n-k)!}x^{n-k}\\&amp;=f(x)e^x\end{aligned}\]</span> 使用我们常微分方程的知识，可以容易得到<span class="math inline">\(f(x)=ce^{e^x}\)</span>，又<span class="math inline">\(f(0)=1\)</span>，故<span class="math inline">\(c=\frac{1}{e}\)</span></p><p>所以我们得到 <span class="math display">\[f(x)=e^{e^x-1}=\frac{1}{e}\sum_{k=0}^{\infty}\frac{(e^x)^k}{k!}=\frac{1}{e}\sum_{k=0}^{\infty}\frac{1}{k!}\sum_{n=0}^{\infty}\frac{(kx)^n}{n!}=\frac{1}{e}\sum_{n=0}^{\infty}(\sum_{k=0}^{\infty}\frac{k^n}{k!})\frac{x^n}{n!}\]</span> 所以我们得到<span class="math inline">\(B_n=\frac{1}{e}\sum\limits_{k=0}^{\infty}\frac{k^n}{k!}\)</span></p><p>在这个例子中，我们可以发现使用指数生成函数求解数列的一般步骤和普通生成函数并没有什么太大的差别。但对于含有组合数的求和类的递推关系，我们更倾向于使用指数生成函数，因为可以去掉组合数的分子，并且得到另外一些指数生成函数形式的无穷级数。</p><p>正如前面提到的，排列数的指数生成函数非常简洁优美，所以指数生成函数与<strong>排列</strong>类计数问题有密不可分的联系。与普通生成函数类似，我们给出另一个类似的经典的排列类计数问题。</p><h3 id="典中典2">典中典2</h3><p>给出另一个命题：</p><p><strong>从<span class="math inline">\(n\)</span>元集<span class="math inline">\(S=\{S_1,S_2,\cdots,S_n\}\)</span>中选取<span class="math inline">\(k\)</span>个元的排列数为<span class="math inline">\(a_k\)</span>，其中要求<span class="math inline">\(S_i\)</span>出现的次数集为<span class="math inline">\(M_i\)</span>，则<span class="math inline">\(\{a_k\}\)</span>的指数生成函数<span class="math inline">\(\sum\limits_{k=0}^{\infty}a_k\frac{x^k}{k!}=\prod\limits_{i=1}^{n}(\sum\limits_{m\in M_i}\frac{x^m}{m!})\)</span></strong></p><p>证明：对数列单独考虑，考虑<span class="math inline">\(m_1+m_2+\cdots+m_n=k,S_i\)</span>恰取<span class="math inline">\(m_i\)</span>的排列数为<span class="math inline">\(\frac{k!}{m_1!m_2!\cdots m_n!}\)</span></p><p>而等式右边<span class="math inline">\(x^k\)</span>的系数为<span class="math inline">\(\sum\limits_{\begin{aligned}m_1+m_2+&amp;\cdots+m_n=k\\m_i\in &amp;M_i\end{aligned}}\frac{1}{m_1!m_2!\cdots m_n!}\)</span>，也就意味着<span class="math inline">\(\sum\limits_{\begin{aligned}m_1+m_2+&amp;\cdots+m_n=k\\m_i\in &amp;M_i\end{aligned}}\frac{k!}{m_1!m_2!\cdots m_n!}\)</span>为<span class="math inline">\(\frac{x^k}{k!}\)</span>前的系数</p><h4 id="一个例子-1">一个例子</h4><p>有1,2,3,4​能组成多少个五位数？要求这些五位数中1出现2次或3次，2至多出现1次，4出现偶数次</p><h4 id="解-1">解</h4><p>为了方便考虑，我们暂时不考虑具体的<span class="math inline">\(n\)</span>，转而考虑求得一般的<span class="math inline">\(n\)</span>的生成函数。</p><p>可以看出来，在本问题中，<span class="math inline">\(M_1=\{2,3\},M_2=\{0,1\},M_3=\{0,1,2,\cdots\},M_4=\{0,2,4,\cdots\}\)</span></p><p>所以我们得到生成函数 <span class="math display">\[\begin{aligned}f(x)&amp;=\sum_{n=0}^{\infty}a_n\frac{x^n}{n!}=(\frac{x^2}{2!}+\frac{x^3}{3!})(1+x)(1+x+\frac{x^2}{2!}+\cdots)(1+\frac{x^2}{2!}+\cdots)=(\frac{x^2}{2}+\frac{x^3}{6})(1+x)e^x\frac{e^x+e^{-x}}{2}\\&amp;=\frac{1}{2}(\frac{x^2}{2}+\frac{x^3}{6})(1+x)(e^{2x}+1)=\frac{1}{12}x^2(3+4x+x^2)(\sum_{n=0}^{\infty}\frac{(2x)^n}{n!}+1)\end{aligned}\]</span> 从而我们得到<span class="math inline">\(a_5=\frac{5!}{12}(3\times\frac{2^3}{3!}+4\times\frac{2^2}{2!}+1\times\frac{2^1}{1})=140\)</span></p><p>容易看出上述问题是一类排列问题</p><h2 id="狄利克雷生成函数">狄利克雷生成函数</h2><p>除了普通生成函数和指数生成函数，还有一类狄利克雷生成函数。在数论中是十分重要的工具。</p><p>先给出狄利克雷卷积的定义，如下 <span class="math display">\[f(s)=\sum_{n=1}^{\infty}\frac{a_n}{n^s}\]</span> 对于数列<span class="math inline">\(\{1\}\)</span>，它的狄利克雷生成函数就是著名的Riemann-Zeta函数<span class="math inline">\(\zeta(s)\triangleq\sum\limits_{n=1}^{\infty}\frac{1}{n^s}\)</span></p><h3 id="一些运算性质-2">一些运算性质</h3><p>我们设<span class="math inline">\(f(s),g(s)\)</span>为<span class="math inline">\(\{a_n\},\{b_n\}\)</span>的狄利克雷生成函数</p><h4 id="乘法dirichlet卷积">乘法（Dirichlet卷积）</h4><p><span class="math display">\[f(s)g(s)=(\sum_{n=1}^{\infty}\frac{a_n}{n^s})(\sum_{n=1}^{\infty}\frac{b_n}{n^s})=\sum_{n=1}^{\infty}\frac{1}{n^s}(\sum_{d|n}a_nb_{\frac{n}{d}})\]</span></p><p>从而<span class="math inline">\(f(s)g(s)\)</span>是<span class="math inline">\({\sum\limits_{d|n}a_db_{\frac{n}{d}}}\)</span>的生成函数</p><h5 id="方幂">方幂</h5><p><span class="math inline">\(f^k(s)\)</span>是数列 <span class="math display">\[\lbrace\sum_{n_1n_2\cdots n_k=n}a_{n_1}a_{n_2}\cdots a_{n_k}\rbrace\]</span> 的狄利克雷生成函数</p><p>由乘法性质容易推出</p><h3 id="积性函数的狄利克雷生成函数">积性函数的狄利克雷生成函数</h3><p>若<span class="math inline">\(f\)</span>为积性函数，则<span class="math inline">\(\{f(n)\}\)</span>的狄利克雷生成函数有如下形式（<span class="math inline">\(p\)</span>表示所有质数） <span class="math display">\[\sum_{n=1}^{\infty}\frac{f(n)}{n^s}=\prod_{p}(\sum_{k=0}^{\infty}f(p^k)p^{-ks})\]</span> 证明：</p><p>考虑<span class="math inline">\(n\)</span>的质因数分解<span class="math inline">\(n=\prod\limits_{i=1}^rp_i^{a_i}\)</span>，则<span class="math inline">\(\prod_{p}(\sum_{k=0}^{\infty}f(p^k)p^{-ks})\)</span>中与<span class="math inline">\(f(n)\)</span>有关的项为 <span class="math display">\[\prod_{i=1}^{r}f(p_i^{a_i})p_i^{-a_is}=\frac{\prod_{i=1}^{r}f(p_i^{a_i})}{\prod_{i=1}^{r}p_i^{a_is}}=\frac{\prod_{i=1}^{r}f(p_i^{a_i})}{(\prod_{i=1}^{r}p_i^{a_i})^s}=\frac{\prod_{i=1}^{r}f(p_i^{a_i})}{n^s}\]</span> 故<span class="math inline">\(\{f(n)\}\)</span>的狄利克雷生成函数中<span class="math inline">\(\frac{1}{n^s}\)</span>的系数为<span class="math inline">\(\prod_{i=1}^{r}f(p_i^{a_i})=f(\prod_{i=1}^{r}p_i^{a_i})=f(n)\)</span></p><h3 id="典中典3">典中典3</h3><p>给出一个命题，与普通生成函数和指数生成函数的颇为相似</p><p><span class="math inline">\(\zeta^k(s)\)</span>生成了<span class="math inline">\(n\)</span>的所有可分解为<span class="math inline">\(k\)</span>个有序正因子积的方法，而<span class="math inline">\((\zeta(s)-1)^k\)</span>生成了<span class="math inline">\(n\)</span>的可分解为<span class="math inline">\(k\)</span>个有序非平凡正因子（每个都大于1）积的方法数</p><h3 id="mobius反演的另一个证明">Mobius反演的另一个证明</h3><p>使用狄利克雷生成函数可以非常巧妙的证明Mobius反演，即</p><p>若<span class="math inline">\(a_n=\sum\limits_{d|n}b_d\)</span>,则<span class="math inline">\(b_n=\sum\limits_{d|n}\mu(\frac{n}{d})a_d\)</span></p><p>先求Mobius函数<span class="math inline">\(\mu(n)\)</span>的狄利克雷生成函数<span class="math inline">\(\tilde{\mu}\)</span>： <span class="math display">\[\sum_{n=1}^{\infty}\frac{\mu(n)}{n^s}=\prod_p(1-p^{-s})\]</span> 又 <span class="math display">\[\zeta(s)=\sum_{n=1}^{\infty}\frac{1}{n^s}=\prod_p(\sum_{k=0}^{\infty}p^{-ks})=\prod_p\frac{1}{1-p^{-s}}\]</span> 从而<span class="math inline">\(\tilde{\mu}\cdot\zeta=1\)</span></p><p>证明：设<span class="math inline">\(\{a_n\},\{b_n\}\)</span>的狄利克雷生成函数为<span class="math inline">\(A(s),B(s)\)</span></p><p>则由上述乘法的性质，得到<span class="math inline">\(A=B\cdot\zeta\)</span>,从而<span class="math inline">\(B=A\cdot\tilde{\mu}\)</span>,所以再由乘法的性质<span class="math inline">\(b_n=\sum\limits_{d|n}\mu(\frac{n}{d})a_d\)</span></p><h2 id="总结">总结</h2><p>普通生成函数和指数生成函数可以用于求解很多计数问题，尤其是递推关系的求解；而狄利克雷生成函数在数论方向有极大的用处。</p><p>下一篇博客计划写Polya计数原理，从而更好的解决各种计数问题。</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组合数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何优雅的调试</title>
    <link href="/2022/04/25/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95/"/>
    <url>/2022/04/25/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="如何优雅的调试">如何优雅的调试</h1><h2 id="第零步编译开关">第零步：编译开关</h2><p>善用<span class="math inline">\(-Wall\)</span>编译开关，Dev-C++在<strong>工具-编译选项-代码生成/优化-代码警告-显示最多警告信息(-Wall)</strong>选择Yes。<span class="math inline">\(-Wall\)</span>开关允许编译器输出更多warning信息，包括但不仅限于：不同数据类型之间的比较，if中少了个等号，未使用的变量名，函数返回值错误。</p><h2 id="第一步瞪眼">第一步：瞪眼</h2><p>先根据自己的输出结果推断哪里可能出了问题，再重点检查那部分代码。</p><p>其中一个非常有用的方法，就是通过人脑，代入一组输入，来模拟计算机的运行，一个语句一个语句运行下去，然后思考运行到这句语句为止是否有跟我想要实现的不一样的地方。需要特别注意的是，手动模拟代码的时候，应尽可能少的想当然，尽可能一步一步跟着代码走。</p><p>举个例子，在手写链表的时候，如果发现输出和输入正好相反，就是</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Input</span>: <span class="hljs-number">10</span> <span class="hljs-number">3</span> <span class="hljs-number">7</span> <span class="hljs-number">12</span> <span class="hljs-number">1</span> -<span class="hljs-number">1</span><br><span class="hljs-attribute">Output</span>: <span class="hljs-number">1</span> <span class="hljs-number">12</span> <span class="hljs-number">7</span> <span class="hljs-number">3</span> <span class="hljs-number">10</span><br></code></pre></div></td></tr></table></figure><p>那么就应该着重去看有关输出的代码出现了什么问题。</p><p>之后，重要的是学会看编译器的报错信息。以下为一个例子</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">camp903.cpp: In function <span class="hljs-string">&#x27;void solve()&#x27;</span>:<br>camp903.cpp:<span class="hljs-number">67</span>:<span class="hljs-number">15</span>: warning: unknown conversion type character <span class="hljs-string">&#x27;l&#x27;</span> in format [-Wformat=]<br>   <span class="hljs-number">67</span> |     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans);<br>      |               ^<br>camp903.cpp:<span class="hljs-number">67</span>:<span class="hljs-number">12</span>: warning: too many arguments <span class="hljs-keyword">for</span> format [-Wformat-extra-args]<br>   <span class="hljs-number">67</span> |     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans);<br></code></pre></div></td></tr></table></figure><p>说明了什么？</p><p>在函数<span class="math inline">\(void\  solve()\)</span>里面，代码中的<strong>67</strong>行，对应着printf(“%lld\n", ans);这条语句，出现了一个<span class="math inline">\(warning\)</span>信息，意思是<strong>未知的标识符<span class="math inline">\(l\)</span></strong>.</p><p>再举一个例子</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">.\camp904.cpp: In function <span class="hljs-string">&#x27;void dfs_lca(int, int)&#x27;</span>:<br>.\camp904.cpp:<span class="hljs-number">87</span>:<span class="hljs-number">16</span>: error: invalid conversion from <span class="hljs-string">&#x27;int (*)[32]&#x27;</span> to <span class="hljs-string">&#x27;int&#x27;</span> [-fpermissive]<br>   <span class="hljs-number">87</span> |     fa[u][<span class="hljs-number">0</span>] = fa;<br>      |                ^~<br>      |                |<br>      |                <span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (*)[<span class="hljs-number">32</span>]<br></code></pre></div></td></tr></table></figure><p>意思就是在函数<span class="math inline">\(void\  dfs\_lca(int, int)\)</span>中，代码中的第<span class="math inline">\(87\)</span>行<span class="math inline">\(16\)</span>列，出现了一个<strong>非法的从<span class="math inline">\(int (*)[32]\)</span>转换到<span class="math inline">\(int\)</span>的错误</strong></p><p>为什么会有非法的类型转换？因为这是一个赋值操作，赋值给了一个类型不匹配并且无法强制转换到目标类型的值，所以解决方法就是修改后面的变量。</p><p>总而言之，就是通过编译器给的具体错误定位，包括函数，第几行第几列，以及什么类型的错误，也就是<span class="math inline">\(error:\)</span>后面的英文，翻译懂吧，翻译，来确定错误点，然后修改错误</p><h2 id="第二步静态查错">第二步：静态查错</h2><p>到这，就是编译器无法发现的错误了，也就是所谓的“逻辑错误”。</p><p>那什么是静态查错？</p><p>就是在完成的函数中，在某些地方增加<span class="math inline">\(printf\)</span>语句输出变量的值，来观察整个程序运行过程中，变量的值的改变的行为是否符合我们的预期。由于是等待整个程序运行完成后一并查看变量在所有运行流程中的值，相对于动态，也就是程序边运行边查看变量的值，的查错方法，所以称为静态查错。</p><p>一般而言，输出变量的值的位置，会被添加在<strong>读入用户输入后、某段特定功能代码执行过程中（例如循环里面）和执行后、某个函数执行后</strong>，以此一步步缩小错误点，最终定位到错误发生的位置。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">290</span>; i &gt;= <span class="hljs-number">175</span>; i--) &#123;<br>    <span class="hljs-keyword">if</span>(v[i].<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-comment">//printf(&quot;%d\n&quot;, v[i].size());</span><br>    <span class="hljs-keyword">if</span>(v[i].<span class="hljs-built_in">size</span>() &lt;= k) ans += v[i].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">int</span> great = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">rep</span>(j, <span class="hljs-number">0</span>, v[i].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span>(v[i][j] &gt;= s) great++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(great + k &gt;= v[i].<span class="hljs-built_in">size</span>()) ans += v[i].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">else</span> ans += (great + k);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在这段代码中，我怀疑<span class="math inline">\(v[i].size()\)</span>可能出现了什么问题，我就在每次循环运行的时候让他输出<span class="math inline">\(v[i].size()\)</span>，也就是注释掉的那行代码，观察是否跟我预期的结果一样。倘若<span class="math inline">\(v[i].size()\)</span>不符合预期，就可以往前思考是什么修改了<span class="math inline">\(v[i].size()\)</span>，进而一步步定位错误点。</p><p>当然，输出可以变得更加user-friendly一点，比如也顺带输出<span class="math inline">\(i\)</span>的值，便可以知道是在那一层循环里输出了对应的值。</p><p>也可以多次使用这种方法，就是在程序中添加多个<span class="math inline">\(printf\)</span>语句，来观察某一个部分的运行情况以及程序整体的运行情况。</p><p>到这为止，基本上可以解决99%的问题了，但有些问题是程序整个部分有问题导致的，他每一块都是对的，但加到一起就不对了，或者是一些更加细小的错误，或者是一些运行时错误（即RE）导致的程序异常退出问题，可以借助<strong>GDB</strong>定位错误点。</p><h2 id="第三步gdb">第三步：GDB</h2><p>在此我非常推荐使用Windows的各位安装一个Ubuntu WSL，在Windows应用商店里可以找到。</p><p>因为在Linux下，有些RE是会被输出在控制台的，比如<span class="math inline">\(Segmentation\  fault\)</span>.</p><p>也可以使用DEV-C++自带的调试器，他也是调用了GDB，但我对这个东西印象非常不好（在NOIP2018的考场上他就没有正常运行起来过！）。使用方法也比较简单，在DEBUG模式下编译，右键行号以添加断点，在下方的“调试”菜单中添加查看变量，在这贴上一篇博客，里面比较详细的介绍了DEV-C++自带的调试器的用法<a href="https://blog.csdn.net/qq_41854911/article/details/121719507">Dev C++调试程序方法详解</a></p><p>接下来介绍命令行（终端）下的GDB的简要用法</p><h3 id="第零步配置环境">第零步：配置环境</h3><p>右键“此电脑”-属性-高级系统设置-环境变量-用户变量中双击<strong>Path</strong>打开，点击新建，将g++编译器的文件路径（例如<strong>C:\MinGW\bin</strong>）复制进去，然后一路确定下去。</p><p>在WSL下，输入sudo apt-get install gcc安装gcc和g++环境</p><h3 id="第一步生成文件">第一步：生成文件</h3><p>可以使用DEV-C++编译，也可以在cmd（或者终端）中先<span class="math inline">\(cd\)</span>到<span class="math inline">\(c++\)</span>文件所在路径，比如cd c:\Users\hands\Desktop.</p><p>随后输入g++ ./$你的文件名$.cpp -o a -g -Wall -std=c++11</p><p>生成完后，再输入gdb ./a.exe（如果是Ubuntu的话就是gdb ./a)，就可以开始使用GDB了</p><h3 id="第三步熟悉命令">第三步：熟悉命令</h3><p>下面只列出一些用的较多的命令，其他更多功能可以自行搜索（</p><table><colgroup><col style="width: 13%"><col style="width: 12%"><col style="width: 74%"></colgroup><thead><tr class="header"><th>命令</th><th>功能</th><th>使用方法</th></tr></thead><tbody><tr class="odd"><td>r(run)</td><td>运行程序</td><td>直接输入r，表示开始调试</td></tr><tr class="even"><td>b(break)</td><td>添加断点</td><td>b 行数，例如“b 100”，在b行让程序停止运行，便于查看变量信息</td></tr><tr class="odd"><td>d(delete)</td><td>删除断点</td><td>d 行数，删除该行处已经设置过的断点</td></tr><tr class="even"><td>p(print)</td><td>输出变量</td><td>p variable，输出变量variable的值，可以是<strong>结构体，数组，地址</strong>等</td></tr><tr class="odd"><td>n(next)</td><td>执行下一行</td><td>直接输入n，执行下一行内容，不管内容多么复杂</td></tr><tr class="even"><td>s(step)</td><td>执行下一行</td><td>直接输入s，与上面的区别是如果下一行是函数会进入函数，而不是直接执行完函数</td></tr><tr class="odd"><td>c(continue)</td><td>继续</td><td>直接输入c，执行到下一个断点处后停止</td></tr><tr class="even"><td>i(info)</td><td>查看信息</td><td>一些常用的subcommand是：info local(查看当前局部变量)，info symbol(查看全局变量，需要加上地址)</td></tr><tr class="odd"><td>quit</td><td>退出调试</td><td>退出调试</td></tr></tbody></table><p>需要注意的是，上述命令，是在<strong>非程序要求用户输入</strong>的时候输入的，也就是出现<strong>(gdb)</strong>的时候输入</p><p>当然这只是一些入门用法，GDB完全可以变得更加强大，进阶用法可以在各类博客轻松找到</p><h3 id="第四步自己尝试">第四步：自己尝试</h3><p>自己动手试试，一切就会变得熟悉起来的。</p><p>命令不是重点，会用，能达成调试的目的就行。</p><p>重要的是观察变量的变化，动态的变化，程序运行过程中的变化，来定位错误点</p><p>如果用不惯GDB也可以转头去用DEV-C++的调试器（</p><p>相比于静态查错，GDB可以帮助我们更好的观察出一些错误，而不用对着所有运行时变量反向推理是哪一步出了什么问题。</p><h2 id="写在最后">写在最后</h2><p>调试是写程序过程中非常非常重要的事情，最好是自己来完成这最后一步，熟练了debug才能更好的理解程序的运行，能力也就提高了。</p><p>比如瞪眼可以帮助理解程序如何运行，进一步厘清自己的思路</p><p>静态可以帮助理解程序内部的联系</p><p>GDB可以观察到更深层次的运行过程</p><p>debug也是提升能力的一个必不可少的关键步骤，会写也会调试，那才能说是真正学习了编程。</p>]]></content>
    
    
    
    <tags>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从积性函数到莫比乌斯反演</title>
    <link href="/2022/04/01/%E4%BB%8E%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0%E5%88%B0%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    <url>/2022/04/01/%E4%BB%8E%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0%E5%88%B0%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/</url>
    
    <content type="html"><![CDATA[<h1 id="从积性函数到莫比乌斯反演">从积性函数到莫比乌斯反演</h1><p>呜呜呜，为了数论课不做大牢，学数论！</p><h2 id="简单介绍">简单介绍</h2><h3 id="数论函数">数论函数</h3><p>数论函数，简单来说就是定义域是<span class="math inline">\(\mathbb{N^{*}}\)</span>的函数，可以视为一个数列</p><h3 id="积性函数">积性函数</h3><h4 id="定义">定义</h4><p>积性函数是一类特殊的数论函数，它满足以下性质 <span class="math display">\[f(1) = 1.\ \forall i, j\in\mathbb{N^{*}},gcd(i,j)=1: f(i*j)=f(i)*f(j)\]</span> 特别的</p><p>若积性函数被称为完全积性函数，若它满足以下性质 <span class="math display">\[\forall i,j\in \mathbb{N^{*}}:f(i*j)=f(i)*f(j)\]</span></p><h4 id="性质">性质</h4><p>设<span class="math inline">\(f\)</span>,<span class="math inline">\(g\)</span>为积性函数，则 <span class="math display">\[h(x)=f(x)*g(x),\ h(x)=f(x^{p}),\ h(x)=f^{p}(x),\ h(x)=\sum_{d|x}f(d)g(\frac{x}{d})\]</span> 也为积性函数</p><p>特别的，根据唯一分解定理，设<span class="math inline">\(x=\prod p_i^{k_i}\)</span>，若<span class="math inline">\(F\)</span>为积性函数，则有 <span class="math display">\[F(x)=\prod F(p_i^{k_i})\]</span> 若<span class="math inline">\(F\)</span>为完全积性函数，则有 <span class="math display">\[F(x)=\prod F^{k_i}(p_i)\]</span></p><h4 id="例子">例子</h4><p>恒等函数<span class="math inline">\(id(n) \equiv n\)</span></p><p>单位函数<span class="math inline">\(\epsilon (n)=[n=1]\)</span></p><p>常数函数<span class="math inline">\(1(n)\equiv 1\)</span></p><p>因子和函数<span class="math inline">\(\delta(n)=\sum_{d|n}d\)</span></p><p>因子个数函数<span class="math inline">\(\tau(n)=\sum_{d|n}1\)</span></p><p>一般的，除数函数<span class="math inline">\(\sigma_k(n)=\sum_{d|n}d^k\)</span></p><p>欧拉函数<span class="math inline">\(\phi(n)=\sum_{i=1}^n[gcd(i,n)=1]\)</span>，即<span class="math inline">\(n\)</span>的与<span class="math inline">\(n\)</span>互质的因数的个数</p><p>莫比乌斯函数，其中<span class="math inline">\(n=\prod_{i=1}^r p_i^{k_i}\)</span> <span class="math display">\[\mu(n)=\begin{cases}1,n=1\\0,\exists i, s.t.k_i&gt;=2\\(-1)^r,otherwise\end{cases}\]</span> 值得指出的是，上述前三个函数为完全积性函数</p><h3 id="dirichlet卷积"><span class="math inline">\(Dirichlet\)</span>卷积</h3><h4 id="定义-1">定义</h4><p>设<span class="math inline">\(f\)</span>和<span class="math inline">\(g\)</span>为数论函数，则两者的<span class="math inline">\(Dirichlet\)</span>卷积<span class="math inline">\(f*g\)</span>定义如下 <span class="math display">\[f*g(n):=\sum_{d|n}f(d)g(\frac{n}{d})\]</span></p><h4 id="性质-1">性质</h4><p><span class="math inline">\(f\)</span>,<span class="math inline">\(g\)</span>,<span class="math inline">\(h\)</span>为数论函数</p><h5 id="单位元存在性">单位元存在性</h5><p><span class="math inline">\(\forall f, \exists \epsilon :f*\epsilon \equiv f\)</span></p><h5 id="逆元唯一性">逆元唯一性</h5><p>若<span class="math inline">\(\exists g, s.t.f*g\equiv\epsilon\)</span>，则称<span class="math inline">\(g\)</span>为<span class="math inline">\(f\)</span>的逆元，事实上，逆元唯一</p><h5 id="交换律">交换律</h5><p><span class="math inline">\(f*g=g*f\)</span></p><h5 id="结合律">结合律</h5><p><span class="math inline">\(f*(g*h)=(f*g)*h\)</span></p><h5 id="分配律">分配律</h5><p><span class="math inline">\(f*(g+h)=f*g+f*h\)</span></p><h5 id="恒等关系">恒等关系</h5><p><span class="math inline">\(f=g\iff f*h=g*h\)</span></p><h4 id="重要结论">重要结论</h4><p><strong>1.积性函数的卷积仍为积性函数</strong></p><p><strong>2.积性函数的逆元也为积性函数</strong></p><h4 id="例子-1">例子</h4><p>1.<span class="math inline">\(\epsilon=\mu*1\)</span></p><p>2.<span class="math inline">\(\tau=1*1\)</span></p><p>3.<span class="math inline">\(\delta=id*1\)</span></p><p><strong>4.<span class="math inline">\(\phi=\mu*n\)</span></strong></p><h2 id="数论分块">数论分块</h2><p>数论分块可以用于快速求解带<strong>向下取整</strong>（显然也有整除）的和式，时间复杂度可以达到<span class="math inline">\(O(\sqrt n)\)</span></p><h3 id="两个结论">两个结论</h3><p>1.<span class="math inline">\(\forall a,b,c\in\mathbb{Z}, \lfloor\frac{\lfloor\frac{a}{b}\rfloor}{c}\rfloor=\lfloor\frac{a}{bc}\rfloor\)</span></p><p>2.<span class="math inline">\(\forall n\in\mathbb{N^*},|V|=\{\lfloor\frac{n}{d}\rfloor|\forall d, 1 \le d\le n\}| \le 2\lfloor\sqrt{n}\rfloor\)</span></p><p>所以可以枚举每个整数<span class="math inline">\(d\)</span>对应的<span class="math inline">\(i\)</span>的区间，来分块计算各个小区间对应的答案，最后相加就行，实现如下</p><h3 id="实现">实现</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">ll <span class="hljs-title">partitioning</span><span class="hljs-params">(ll n)</span> </span>&#123;<br>    ll ans = <span class="hljs-number">0</span>;<br>    ll l, r;<br>    <span class="hljs-keyword">for</span>(l = <span class="hljs-number">1</span>; l &lt;= n; l++) &#123;<br>        r = n / (n / l);<br>        ans += <span class="hljs-number">1LL</span> * (r - l + <span class="hljs-number">1</span>) * <span class="hljs-built_in">expression</span>(l);\\expression is the formula that is to be solved<br>        l = r;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="莫比乌斯反演">莫比乌斯反演</h2><p>来到了，高一集训时的噩梦，<span class="math inline">\(cjq\)</span>大仙的解方程猜测<span class="math inline">\(\mu\)</span>函数现场，四年来念念不忘的<strong>Mobius Inversion</strong></p><h3 id="mu函数的补充"><span class="math inline">\(\mu\)</span>函数的补充</h3><p><span class="math inline">\([gcd(i,j)=1]=\sum_{d|gcd(i,j)} {\mu(d)}\)</span></p><p>即<span class="math inline">\([gcd(i,j)=1]=\epsilon *gcd(i,j)\)</span></p><p>显然，如果<span class="math inline">\(gcd(i,j)=1\)</span>，那么d只能取<span class="math inline">\(1\)</span>，故和式为<span class="math inline">\(1\)</span>；若不然，<span class="math inline">\(gcd(i,j)\)</span>的因子总是成对出现，故可取到的<span class="math inline">\(\mu\)</span>中<span class="math inline">\((-1)^r\)</span>的<span class="math inline">\(r\)</span>总是连续的<span class="math inline">\(1-2n\)</span>，故结果为<span class="math inline">\(0\)</span></p><h3 id="线性筛">线性筛</h3><p>线性筛可以用于求绝大部分积性函数（其实我也不知道有什么不能求的），区别只在于在线性筛过程中对函数值的处理计算</p><p>对于<span class="math inline">\(\mu\)</span>函数，实现如下</p><h4 id="实现-1">实现</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getMu</span><span class="hljs-params">()</span> </span>&#123;<br>    mu[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    inp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= maxn; i++) &#123;<br>        <span class="hljs-keyword">if</span>(!inp[i]) prime[++tot] = i, mu[i] = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= tot &amp;&amp; i * prime[j] &lt;= maxn; j++) &#123;<br>            inp[i * prime[j]] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(i % prime[j] == <span class="hljs-number">0</span>) &#123;<br>                mu[i * p[j]] = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            mu[i * p[j]] = -mu[i];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="结论">结论</h3><p><span class="math inline">\(f\)</span>和<span class="math inline">\(g\)</span>为两个数论函数，若 <span class="math display">\[f(n)=\sum_{d|n}g(d)\]</span> 则有 <span class="math display">\[g(n)=\sum_{d|n}\mu(d)f(\frac{n}{d})\]</span> <span class="math inline">\(f\)</span>称为<span class="math inline">\(g\)</span>的莫比乌斯变换，<span class="math inline">\(而g\)</span>称为<span class="math inline">\(f\)</span>的莫比乌斯反演，可以看出，<span class="math inline">\(f = g*1\)</span></p><p>那么，如果遇到 <span class="math display">\[\sum_{i=1}^n\sum_{j=1}^m [gcd(i,j)=1]\]</span> 就可以转化为 <span class="math display">\[\sum_{i=1}^n\sum_{j=1}^m\sum_{d|gcd(i,j)}{\mu(d)}\]</span> 改变求和顺序，可以得到 <span class="math display">\[\sum_{d=1}\mu(d)\sum_{i = 1}^n[d|i]\sum_{j=1}^m[d|j]\]</span> 显然后面两个求和号可以直接得出结果，故 <span class="math display">\[\sum_{i=1}^n\sum_{j=1}^m [gcd(i,j)=1]=\sum_{d=1}^{min(n,m)}\mu(d)\lfloor\frac{n}{d}\rfloor\lfloor\frac{m}{d}\rfloor\]</span> 直接使用数论分块解决即可</p><h3 id="实现-2">实现</h3><p>以<a href="https://www.luogu.com.cn/problem/P2522">[HAOI2011] Problem b</a>为例</p><p>推导与上述无异，再使用二维容斥即可解决问题</p><p>即计算 <span class="math display">\[\sum_{d=1}^{min(\lfloor\frac{n}{k}\rfloor,\lfloor\frac{m}{k}\rfloor)}\mu(d)\lfloor\frac{n}{kd}\rfloor\lfloor\frac{m}{kd}\rfloor\]</span> 令<span class="math inline">\(n=b,m=d;n=b,m=c-1;n=a-1,m=d;n=a-1,m=c-1\)</span>四种情况即可</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n, mu[maxn], prime[maxn], tot = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">bool</span> inp[maxn];<br><span class="hljs-keyword">int</span> a, b, c, d, k;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//get prefix of mu</span><br>    mu[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>, inp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">2</span>, maxn) &#123;<br>        <span class="hljs-keyword">if</span>(!inp[i]) &#123;<br>            prime[++tot] = i;<br>            mu[i] = <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= tot &amp;&amp; i * prime[j] &lt;= maxn; j++) &#123;<br>            inp[i * prime[j]] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(i % prime[j] == <span class="hljs-number">0</span>) &#123;<br>                mu[i * prime[j]] = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            mu[i * prime[j]] = -mu[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, maxn) mu[i] += mu[i - <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">cal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123; <span class="hljs-comment">//calculate the sum</span><br>    ll ans = <span class="hljs-number">0</span>;<br>    ll l, r;<br>    <span class="hljs-keyword">for</span>(l = <span class="hljs-number">1</span>; l &lt;= <span class="hljs-built_in">min</span>(n, m); l++) &#123;<br>        r = <span class="hljs-built_in">min</span>(n / (n / l), m / (m / l));<br>        ans += <span class="hljs-number">1LL</span> * (mu[r] - mu[l - <span class="hljs-number">1</span>]) * (n / l) * (m / l);<br>        l = r;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    a = <span class="hljs-built_in">read</span>(), b = <span class="hljs-built_in">read</span>(), c = <span class="hljs-built_in">read</span>(), d = <span class="hljs-built_in">read</span>(), k = <span class="hljs-built_in">read</span>();<br>    ll res = <span class="hljs-built_in">cal</span>(b / k, d / k) - <span class="hljs-built_in">cal</span>((a - <span class="hljs-number">1</span>) / k, d / k) - <span class="hljs-built_in">cal</span>(b / k, (c - <span class="hljs-number">1</span>) / k) + <span class="hljs-built_in">cal</span>((a - <span class="hljs-number">1</span>) / k, (c - <span class="hljs-number">1</span>) / k);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, res);<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>莫比乌斯反演</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可持久化线段树</title>
    <link href="/2022/03/06/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <url>/2022/03/06/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="可持久化线段树学习笔记">可持久化线段树学习笔记</h1><h2 id="前言">前言</h2><p>之前写到一题区间第k大相关的题，可惜不会主席树，就现在学了一学</p><h2 id="前置知识">前置知识</h2><p>1、线段树</p><p>2、离散化</p><h2 id="正式开始">正式开始</h2><p>可持久化线段树是维护历史版本的一个数据结构</p><p>要查询区间第k大，自然就可以想到<strong>维护<span class="math inline">\(1-i\)</span>在这个区间<span class="math inline">\([l,r]\)</span>里个数</strong></p><p>为了简化问题，可以率<strong>先考虑区间<span class="math inline">\([1,k]\)</span>里的数字</strong>，随后运用<strong>前缀和</strong>解决问题</p><p>但如果每次操作都保存一棵线段树，这样子空间肯定会爆掉（</p><p>所以我们用更为优雅的方法记录历史版本</p><p>观察发现，每次操作只会更新线段树上的一条链，所以我们可以<strong>只保存一条链</strong>，并且跟原来的一整棵线段树的一部分节点构建父子关系</p><p>这样一来，就可以大大降低空间的使用了</p><p>下面来几张图解释一下建树的过程</p><p>我们以<span class="math inline">\([25957,6405,15770,26287,26465]\)</span>为例，先对他离散化，得到<span class="math inline">\([3,1,2,4,5]\)</span></p><p>先建一棵空树</p><figure><img src="/2022/03/06/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/1.PNG" alt="1"><figcaption aria-hidden="true">1</figcaption></figure><p>然后添加第一个节点，也就是离散化后的<span class="math inline">\(&#39;3&#39;\)</span></p><figure><img src="/2022/03/06/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/2.PNG" alt="2"><figcaption aria-hidden="true">2</figcaption></figure><p>然后以此类推，最后的树长成这样</p><figure><img src="/2022/03/06/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/6.PNG" alt="6"><figcaption aria-hidden="true">6</figcaption></figure><p>不同的颜色表示了不同的操作次数</p><p>显然，我们无法使用跟普通线段树类似的堆的方法存储节点的左右孩子，所以需要另外开两个数组存储</p><p>查询时，我们只需要对左子树做差，得到一个值<span class="math inline">\(x\)</span>，如果结果大于我们需要的<span class="math inline">\(k\)</span>，那就从右子树继续查询，但查询的值得减去<span class="math inline">\(x\)</span>；如果小于，就继续从左子树查询</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ql, <span class="hljs-keyword">int</span> qr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>, x = sum[ls[qr]] - sum[ls[ql]];<br>    <span class="hljs-keyword">if</span>(l == r) <span class="hljs-keyword">return</span> l;<br>    <span class="hljs-keyword">if</span>(k &lt;= x) <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(ls[ql], ls[qr], l, mid, k);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(rs[ql], rs[qr], mid + <span class="hljs-number">1</span>, r, k - x);<br></code></pre></div></td></tr></table></figure><p>为了实现这个数据结构，我们还需要一个数组<span class="math inline">\(rt\)</span>来存储每一棵线段树的根节点的信息，也就是上图中最上面的一层。</p><p>至此，我们已经悟了主席树是个什么东西和大概怎么实现，细节部分会在下面实现的代码中呈现</p><h2 id="实现">实现</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> LOG = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">int</span> n, m, len, tot;<br><span class="hljs-keyword">int</span> a[maxn], ind[maxn];<br><span class="hljs-keyword">int</span> sum[maxn * LOG], rt[maxn], ls[maxn * LOG], rs[maxn * LOG];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getid</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;val)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">lower_bound</span>(ind + <span class="hljs-number">1</span>, ind + <span class="hljs-number">1</span> + len, val) - ind;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> root = ++tot;<br>    <span class="hljs-keyword">if</span>(l == r) <span class="hljs-keyword">return</span> root;<br>    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>    ls[root] = <span class="hljs-built_in">build</span>(l, mid);<br>    rs[root] = <span class="hljs-built_in">build</span>(mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> root)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> dir = ++tot;<br>    ls[dir] = ls[root], rs[dir] = rs[root], sum[dir] = sum[root] + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(l == r) <span class="hljs-keyword">return</span> dir;<br>    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(k &lt;= mid) ls[dir] = <span class="hljs-built_in">update</span>(k, l, mid, ls[dir]);<br>    <span class="hljs-keyword">else</span> rs[dir] = <span class="hljs-built_in">update</span>(k, mid + <span class="hljs-number">1</span>, r, rs[dir]);<br>    <span class="hljs-keyword">return</span> dir;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ql, <span class="hljs-keyword">int</span> qr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>, x = sum[ls[qr]] - sum[ls[ql]];<br>    <span class="hljs-keyword">if</span>(l == r) <span class="hljs-keyword">return</span> l;<br>    <span class="hljs-keyword">if</span>(k &lt;= x) <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(ls[ql], ls[qr], l, mid, k);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(rs[ql], rs[qr], mid + <span class="hljs-number">1</span>, r, k - x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    n = <span class="hljs-built_in">read</span>(), m = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) a[i] = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">memcpy</span>(ind, a, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ind));<br>    <span class="hljs-built_in">sort</span>(ind + <span class="hljs-number">1</span>, ind + <span class="hljs-number">1</span> + n);<br>    len = <span class="hljs-built_in">unique</span>(ind + <span class="hljs-number">1</span>, ind + <span class="hljs-number">1</span> + n) - ind - <span class="hljs-number">1</span>;<br>    rt[<span class="hljs-number">0</span>] = <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, len);<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        rt[i] = <span class="hljs-built_in">update</span>(<span class="hljs-built_in">getid</span>(a[i]), <span class="hljs-number">1</span>, len, rt[i - <span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, m) &#123;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-built_in">read</span>(), r = <span class="hljs-built_in">read</span>(), k = <span class="hljs-built_in">read</span>();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ind[<span class="hljs-built_in">query</span>(rt[l - <span class="hljs-number">1</span>], rt[r], <span class="hljs-number">1</span>, len, k)]);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="空间分析">空间分析</h2><p>我们一开始得先开一棵线段树，由于是动态开点，所需空间是<span class="math inline">\(2n-1\)</span>，在后续的更新操作中，每次操作最多需要<span class="math inline">\(\lceil logn\rceil +1\)</span>个点</p><p>综上，我们总共需要<span class="math inline">\(2n-1+n(\lceil logn\rceil +1)\)</span>个点，瞎估估就是<span class="math inline">\(n(3+ \lceil logn\rceil)\)</span>个节点</p><h2 id="时间分析">时间分析</h2><p>我们开一棵空树需要的时间是<span class="math inline">\(O(logn)\)</span>，每次更新和查询的时间开销也是<span class="math inline">\(O(logn)\)</span>的，对于m次查询，总共的时间复杂度就是<span class="math inline">\(O(mlogn)\)</span>的</p><p>还是非常优秀的</p><h2 id="写在最后">写在最后</h2><p>上面是我学习完主席树后的一点笔记，如果您发现了任何问题，请在下面评论直接告诉我（评论期望近期开放）</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模板</tag>
      
      <tag>可持久化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DeterminantCalculator</title>
    <link href="/2021/11/05/DeterminantCalculator/"/>
    <url>/2021/11/05/DeterminantCalculator/</url>
    
    <content type="html"><![CDATA[<p>行列式太难算了</p><p>网上计算器也没过程</p><p>整了一个</p><p>非常丑</p><p>但无所谓了（</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxm 6005</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxn 1010</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inf 2147483647</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxw 13000</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, b) for(int i = a; i &lt;= b; i++)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> loop(i, a, b) for(int i = a; i &gt;= b; i--)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> sqr(x) ((x) * (x))</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    ll s = <span class="hljs-number">0</span>, w = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">char</span> ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;-&#x27;</span>) w = <span class="hljs-number">-1</span>; ch = <span class="hljs-built_in">getchar</span>();&#125;<br>    <span class="hljs-keyword">while</span>(ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;s = s * <span class="hljs-number">10</span> + ch - <span class="hljs-string">&#x27;0&#x27;</span>; ch = <span class="hljs-built_in">getchar</span>();&#125;<br>    <span class="hljs-keyword">return</span> s * w;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* ============================================================================</span><br><span class="hljs-comment">@Author:      Cool_Ball</span><br><span class="hljs-comment">@DateTime:    2021-11-04 21:03:38</span><br><span class="hljs-comment">* ============================================================================</span><br><span class="hljs-comment">*/</span><br><br>ll n;<br><br><span class="hljs-comment">//----------fraction start----------//</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">frac</span> &#123;</span><br>    ll up, down;<br>&#125;;<br><br><span class="hljs-function">ll <span class="hljs-title">gcd</span><span class="hljs-params">(ll a, ll b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">gcd</span>(b, a % b);<br>&#125;<br><br><span class="hljs-function">frac <span class="hljs-title">add</span><span class="hljs-params">(frac a, frac b)</span> </span>&#123;<br>    ll tmp1 = a.down * b.down, tmp2 = a.up * b.down + b.up * a.down;<br>    ll g = <span class="hljs-built_in">gcd</span>(tmp1, tmp2);<br>    tmp1 /= g, tmp2 /= g;<br>    <span class="hljs-keyword">return</span> frac&#123;tmp2, tmp1&#125;;<br>&#125;<br><br><span class="hljs-function">frac <span class="hljs-title">subt</span><span class="hljs-params">(frac a, frac b)</span> </span>&#123;<br>    ll tmp1 = a.down * b.down, tmp2 = a.up * b.down - b.up * a.down;<br>    ll g = <span class="hljs-built_in">gcd</span>(tmp1, tmp2);<br>    tmp1 /= g, tmp2 /= g;<br>    <span class="hljs-keyword">if</span>(tmp1 &lt; <span class="hljs-number">0</span>) &#123;<br>        tmp1 = <span class="hljs-built_in">abs</span>(tmp1);<br>        tmp2 = -tmp2;<br>    &#125;<br>    <span class="hljs-keyword">return</span> frac&#123;tmp2, tmp1&#125;;<br>&#125;<br><br><span class="hljs-function">frac <span class="hljs-title">mul</span><span class="hljs-params">(frac a, frac b)</span> </span>&#123;<br>    ll tmp1 = a.down * b.down, tmp2 = a.up * b.up;<br>    ll g = <span class="hljs-built_in">gcd</span>(tmp1, tmp2);<br>    tmp1 /= g, tmp2 /= g;<br>    <span class="hljs-keyword">return</span> frac&#123;tmp2, tmp1&#125;;<br>&#125;<br><br><span class="hljs-function">frac <span class="hljs-title">div</span><span class="hljs-params">(frac a, frac b)</span> </span>&#123;<br>    ll tmp1 = a.down * b.up, tmp2 = a.up * b.down;<br>    ll g = <span class="hljs-built_in">gcd</span>(tmp1, tmp2);<br>    tmp1 /= g, tmp2 /= g;<br>    <span class="hljs-keyword">return</span> frac&#123;tmp2, tmp1&#125;;<br>&#125;<br><span class="hljs-comment">//----------fraction end----------//</span><br><br><br><span class="hljs-comment">//----------Guass Elimination start----------//</span><br>frac A[maxn][maxn];<br>ll exc = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Guass</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        <span class="hljs-comment">//find largest pivot</span><br>        ll maxx = i;<br>        <span class="hljs-built_in">rep</span>(j, i + <span class="hljs-number">1</span>, n) &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(A[j][i].up * A[maxx][i].down) &gt; <span class="hljs-built_in">abs</span>(A[maxx][i].up * A[j][i].down)) &#123;<br>                maxx = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//row exhange</span><br>        <span class="hljs-keyword">if</span>(maxx != i) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;Switch the &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;-th row with the &quot;</span> &lt;&lt; maxx &lt;&lt; <span class="hljs-string">&quot;-th row&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-built_in">rep</span>(j, <span class="hljs-number">1</span>, n) &#123;<br>                <span class="hljs-built_in">swap</span>(A[i][j], A[maxx][j]);<br>            &#125;<br>            exc++;<br>            <span class="hljs-built_in">rep</span>(o, <span class="hljs-number">1</span>, n) &#123;<br>                <span class="hljs-built_in">rep</span>(p, <span class="hljs-number">1</span>, n) &#123;<br>                    cout &lt;&lt; A[o][p].up;<br>                    <span class="hljs-keyword">if</span>(A[o][p].down != <span class="hljs-number">1</span>) cout &lt;&lt; <span class="hljs-string">&quot;/&quot;</span> &lt;&lt; A[o][p].down;<br>                    cout &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>                &#125;<br>                cout &lt;&lt; endl;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//Guass eliminated to upper triangular matrix</span><br>        <span class="hljs-built_in">rep</span>(j, i + <span class="hljs-number">1</span>, n) &#123;<br>            frac tmp = <span class="hljs-built_in">div</span>(A[j][i] ,A[i][i]);<br>            cout &lt;&lt; <span class="hljs-string">&quot;Subtract the &quot;</span> &lt;&lt; j &lt;&lt; <span class="hljs-string">&quot;-th row with &quot;</span> &lt;&lt; tmp.up &lt;&lt; <span class="hljs-string">&quot;/&quot;</span> &lt;&lt; tmp.down &lt;&lt; <span class="hljs-string">&quot; times of the &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;-th row.&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-built_in">rep</span>(k, i , n) &#123;<br>                A[j][k] = <span class="hljs-built_in">subt</span>(A[j][k], <span class="hljs-built_in">mul</span>(A[i][k], tmp));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i &lt; n) &#123;<br>            <span class="hljs-built_in">rep</span>(o, <span class="hljs-number">1</span>, n) &#123;<br>                <span class="hljs-built_in">rep</span>(p, <span class="hljs-number">1</span>, n) &#123;<br>                    cout &lt;&lt; A[o][p].up;<br>                    <span class="hljs-keyword">if</span>(A[o][p].down != <span class="hljs-number">1</span>) cout &lt;&lt; <span class="hljs-string">&quot;/&quot;</span> &lt;&lt; A[o][p].down;<br>                    cout &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>                &#125;<br>                cout &lt;&lt; endl;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//output the determianat of the martix</span><br>    frac ans = frac&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        ans = <span class="hljs-built_in">mul</span>(ans, A[i][i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The determinant of the matrix is:\n&quot;</span>);<br>    <span class="hljs-keyword">if</span>(exc % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &amp;&amp; ans.up != <span class="hljs-number">0</span>) cout &lt;&lt; <span class="hljs-string">&quot;-&quot;</span>;<br>    cout &lt;&lt; ans.up;<br>    <span class="hljs-keyword">if</span>(ans.down != <span class="hljs-number">1</span>) cout &lt;&lt; <span class="hljs-string">&quot;/&quot;</span> &lt;&lt; ans.down &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//----------Guass Elimination end----------//</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inp</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Please input the matrix(integer or fraction)\n&quot;</span>);<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        <span class="hljs-built_in">rep</span>(j, <span class="hljs-number">1</span>, n) &#123;<br>            <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>;<br>            string s;<br>            cin &gt;&gt; s;<br>            ll num = <span class="hljs-number">0</span>, w = <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">rep</span>(k, <span class="hljs-number">0</span>, s.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">if</span>(s[k] == <span class="hljs-string">&#x27;/&#x27;</span>) &#123;<br>                    flag = <span class="hljs-literal">true</span>;<br>                    A[i][j].up = w * num;<br>                    w = <span class="hljs-number">1</span>, num = <span class="hljs-number">0</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(s[k] == <span class="hljs-string">&#x27;-&#x27;</span>) w = <span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">if</span>(s[k] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[k] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) num = num * <span class="hljs-number">10</span> + s[k] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag) A[i][j].down = w * num;<br>            <span class="hljs-keyword">else</span> &#123;<br>                A[i][j].up = w * num;<br>                A[i][j].down = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Please input the matrix size(n*n)\n&quot;</span>);<br>    n = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">inp</span>();<br>    <span class="hljs-built_in">Guass</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>行列式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拉格朗日插值法</title>
    <link href="/2021/10/21/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E6%B3%95/"/>
    <url>/2021/10/21/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="中国剩余定理和lagrange插值法">中国剩余定理和Lagrange插值法</h1><h2 id="引言">引言</h2><p>很巧，高代课讲到了Lagrange插值法，凭着“上课听不明白只好下课自己搞”的意志，我学学证明顺带来写个板子。</p><h2 id="前置知识中国剩余定理crt">前置知识：中国剩余定理（CRT）</h2><p>中国剩余定理是用来求解形如 <span class="math display">\[\begin{cases}x &amp; \equiv  a_1 (mod \quad m_1) \\x &amp; \equiv  a_2 (mod \quad m_2) \\&amp;...... \\x &amp; \equiv  a_k (mod \quad m_k)\end{cases}\]</span> 的线性同余方程组的解的。其中，<span class="math inline">\(\forall i\neq j \quad (a_i, a_j)=1\)</span>，我们需要找出最小的非负整数解<span class="math inline">\(x\)</span>。</p><h3 id="解法">解法</h3><p>设<span class="math inline">\(M=\prod_{i=0}^k m_i\)</span>,<span class="math inline">\(M_i=\frac{M}{m_i}\)</span>,<span class="math inline">\(M_iT_i \equiv 1(mod \ m_i)\)</span>，其中<span class="math inline">\(1\leq i,j \leq n\)</span>。</p><p>故可以构造一个解<span class="math inline">\(x=\sum_{i=1}^na_iM_it_i\)</span></p><p>由此，可以求出任意解<span class="math inline">\(x_0=x+k*M\)</span></p><p><strong>最小正整数解<span class="math inline">\(X\)</span></strong>即为<span class="math inline">\(x_0\%M\)</span></p><h3 id="证明">证明</h3><p>显然，在第<span class="math inline">\(i\)</span>个同余方程里，<span class="math inline">\(a_jM_jt_j \equiv 0(mod \ m_i)\)</span></p><p><span class="math inline">\(a_iM_it_i \equiv a_i(mod \ m_i)\)</span></p><p>所以<span class="math inline">\(\forall i,X \equiv a_i (mod \ m_i)\)</span>，满足题意。</p><h3 id="乘法逆元">乘法逆元</h3><p>若<span class="math inline">\(a*a^{-1} \equiv 1 (mod \ p)\)</span>，则称<span class="math inline">\(a^{-1}\)</span>是<span class="math inline">\(a\)</span>在<span class="math inline">\(mod \ p\)</span>意义下的逆元。</p><p>用扩展欧几里得<span class="math inline">\((exgcd)\)</span>来求解</p><p>过程如下：</p><p><span class="math display">\[因为a*x+b*y=(a, b)\\且b*x&#39;+(a\%b)*y&#39;=(b,a\%b)\\a\%b=a-\lfloor\frac{a}{b}\rfloor*b\]</span></p><p><span class="math display">\[有a*y&#39;+b*(x&#39;-\lfloor\frac{a}{b}\rfloor*y&#39;)=(a,b)\\故x=y&#39;,y=(x&#39;-\lfloor\frac{a}{b}\rfloor*y&#39;)\]</span></p><p>显然，<span class="math inline">\((M_i, m_i)=1\)</span>，故令<span class="math inline">\(a=M_i, b=m_i\)</span>，则<span class="math inline">\(M_ix+m_iy=1\)</span>，故<span class="math inline">\(M_ix=1-m_iy\)</span>，可得<span class="math inline">\(x\)</span>为<span class="math inline">\(M_i\)</span>在<span class="math inline">\(mod\ m_i\)</span>下的逆元，即为题设所求。</p><h3 id="代码">代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">ll n, a[maxn], m[maxn], Mi[maxn], M = <span class="hljs-number">1</span>, X;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(ll a, ll b, ll &amp;x, ll &amp;y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>) &#123;x = <span class="hljs-number">1</span>; y = <span class="hljs-number">0</span>; <span class="hljs-keyword">return</span>;&#125;<br>    <span class="hljs-built_in">exgcd</span>(b, a % b, x, y);<br>    ll z = x;<br>    x = y, y = z - y * (a / b);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CRT</span><span class="hljs-params">()</span> </span>&#123;<br>    n = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        m[i] = <span class="hljs-built_in">read</span>(), a[i] = <span class="hljs-built_in">read</span>();<br>        M *= m[i];<br>    &#125;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        Mi[i] = M / m[i];<br>        ll x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">exgcd</span>(Mi[i], m[i], x, y);<br>        X += a[i] * Mi[i] * (x &lt; <span class="hljs-number">0</span> ? (x + m[i]):x);<br>    &#125;<br>    cout &lt;&lt; X % M &lt;&lt; endl;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="正片lagrange插值">正片：Lagrange插值</h2><h3 id="多项式储备知识多项式余数">多项式储备知识（多项式余数）</h3><p>已知多项式 <span class="math display">\[f(x)\in P[x],f(x)=\sum_{i=0}^{n}a_ix^i\]</span></p><p><span class="math display">\[故f(x)\%(x-\alpha)=\sum_{i=0}^{n}a_i\alpha^i\]</span></p><p>下证：</p><p>已知 <span class="math display">\[f(x)=\sum_{i=0}^{n}a_ix^i \\f(x)=\sum_{i=0}^{n}a_ix^i=\sum_{i=0}^{n}(x-\alpha+\alpha)^i=\sum_{i=0}^{n}a_i\sum_{j=0}^{i}{i \choose j}(x-\alpha)^j\alpha^{i-j}\]</span></p><p>可知，当<span class="math inline">\(j\neq0\)</span>时，该子项<span class="math inline">\(p\%(x-\alpha)=0\)</span>恒成立 故余数必为<span class="math inline">\(j=0\)</span>的项之和，即 <span class="math display">\[\begin{aligned}r(x)=\sum_{i=0}^{n}a_i\alpha^i\end{aligned}\]</span></p><h3 id="模意义下的推导过程">模意义下的推导过程</h3><p>由上述可以得到一个关于<span class="math inline">\(f(x)\)</span>的同余方程组，即 <span class="math display">\[\begin{cases}f(x) &amp; \equiv  y_1 (mod \ (x-x_1)) \\f(x) &amp; \equiv  y_2 (mod \ (x-x_2)) \\&amp;...... \\f(x) &amp; \equiv  y_n (mod \ (x-x_n))\end{cases}\]</span> 根据<strong>中国剩余定理</strong> <span class="math display">\[\begin{aligned}M=\prod_{i=1}^{n}(x-x_i),M_i=\frac{M}{x-x_i}=\prod_{j\neq i}(x-x_j)\end{aligned}\]</span> 得<span class="math inline">\(M_i\)</span>在<span class="math inline">\(mod(x-x_i)\)</span>意义下的逆元<span class="math inline">\(T_i\)</span>为 <span class="math display">\[\begin{aligned}M_i^{-1}=T_i=\prod_{j\neq i}\frac{1}{x_i-x_j}\end{aligned}\]</span> 故有 <span class="math display">\[\begin{aligned}f(x) \equiv \sum_{i=1}^{n}y_iM_iT_i\equiv \sum_{i=1}^{n}y_i\prod_{j\neq i}M_iT_i\equiv \sum_{i=1}^{n}y_i\prod_{j\neq i}\frac{x-x_i}{x_i-x_j} \quad mod(M)\end{aligned}\]</span></p><p>又<span class="math inline">\(f(x)\)</span>唯一，故 <span class="math display">\[\begin{aligned}f(x) = \sum_{i=1}^{n}y_i\prod_{j\neq i}\frac{x-x_i}{x_i-x_j}\end{aligned}\]</span> 即为Lagrange插值的表达式</p><h3 id="通常意义下的推导过程">通常意义下的推导过程</h3><p>已知<span class="math inline">\(f(x)\)</span>过<span class="math inline">\(n\)</span>个点<span class="math inline">\(P_1(x_1,y_1),P_2(x_2,y_2),...,P_n(x_n,y_n)\)</span>，以及其在<span class="math inline">\(x\)</span>轴上的投影<span class="math inline">\(P_i^{&#39;}(x_i,0)\)</span></p><p>考虑构造<span class="math inline">\(n\)</span>个函数<span class="math inline">\(F_i(x)\)</span>使得其过点， <span class="math display">\[\left\{\begin{aligned}&amp; P_j^{&#39;} \quad j\neq i \\&amp; P_i \quad j=i \end{aligned}\right.\]</span> 则可知所需函数<span class="math inline">\(f(x)=\sum_{i=1}^{n}F_i(x)\)</span>.</p><p>则可设<span class="math inline">\(F_i(x)=a\prod_{j\neq i}(x_i-x_j)\)</span>，将<span class="math inline">\(P_i\)</span>代入可得<span class="math inline">\(a=\frac{y_i}{\prod_{j\neq i}(x_i-x_j)}\)</span>，所以 <span class="math display">\[\begin{aligned}F_i(x)=y_i\prod_{j\neq i}\frac{x-x_j}{x_i-x_j}\end{aligned}\]</span> 由此导出<strong>Lagrange插值在通常意义下的公式</strong>，如下 <span class="math display">\[\begin{aligned}f(x)=\sum_{i=1}^{n}F_i(x)=\sum_{i=1}^{n}y_i\prod_{j\neq i}\frac{x-x_j}{x_i-x_j}\end{aligned}\]</span> 与上述<strong>在模意义下的Lagrange插值公式</strong>相同</p><h2 id="代码实现对xk时即需要求fk的值的代码">代码实现（对<span class="math inline">\(x=k\)</span>时，即需要求<span class="math inline">\(f(k)\)</span>的值的代码）</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> ll p = <span class="hljs-number">998244353</span>;<br>ll n, y[maxn], x[maxn], k;<br>ll ans, s1, s2;<br><br><span class="hljs-function">ll <span class="hljs-title">fastmod</span><span class="hljs-params">(ll a, ll k)</span> </span>&#123;<br>    ll base = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(k) &#123;<br>        <span class="hljs-keyword">if</span>(k &amp; <span class="hljs-number">1</span>) base = base * a % p;<br>        a = a * a % p;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> base % p;<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">inv</span><span class="hljs-params">(ll x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">fastmod</span>(x, p - <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Lagrange</span><span class="hljs-params">()</span> </span>&#123;<br>    n = <span class="hljs-built_in">read</span>(), k = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        x[i] = <span class="hljs-built_in">read</span>(), y[i] = <span class="hljs-built_in">read</span>();<br>    &#125;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        s1 = y[i] % p;<br>        s2 = <span class="hljs-number">1LL</span>;<br>        <span class="hljs-built_in">rep</span>(j, <span class="hljs-number">1</span>, n) &#123;<br>            <span class="hljs-keyword">if</span>(i != j) &#123;<br>                s1 = s1 * (k - x[j]) % p;<br>                s2 = s2 * (x[i]-x[j]) % p;<br>            &#125;<br>        &#125;<br>        ans += s1 * <span class="hljs-built_in">inv</span>(s2) % p;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, (ans % p + p) % p);<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>多项式</tag>
      
      <tag>扩展欧几里得</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>伯努利数</title>
    <link href="/2021/10/17/%E4%BC%AF%E5%8A%AA%E5%88%A9%E6%95%B0/"/>
    <url>/2021/10/17/%E4%BC%AF%E5%8A%AA%E5%88%A9%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="伯努利数">伯努利数</h1><p>今天看吉米多维奇的时候偶然看到伯努利数，一查oi-wiki上也有，就学了一下，就当第一篇博客了。（之后会写FFT和NTT，多项式求逆和多项式除法的）</p><h2 id="背景等幂求和">背景：等幂求和</h2><p><span class="math display">\[\begin{aligned}\sum_{k=0}^{n-1}k^m=\frac{1}{m+1}\sum_{k=0}^mC_{m+1}^kB_kn^{m+1-k}\end{aligned}\]</span></p><p>利用<span class="math inline">\((k+1)^2-k^2=2k+1\)</span>可得 <span class="math display">\[\begin{aligned}\sum_{k=1}^n[(k+1)^2-k^2]=\sum_{k=1}^n(2k+1)\end{aligned}\]</span> 整理后即为 <span class="math display">\[\begin{aligned}\sum_{k=1}^nk=\frac{n(n+1)}{2}\end{aligned}\]</span> 类似的，利用<span class="math inline">\((k+1)^3-k^3=3k^2+3k+1\)</span>可得 <span class="math display">\[\begin{aligned}\sum_{k=1}^n[(k+1)^3-k^3]=\sum_{k=1}^n(3k^2+3k+1)=3\sum_{k=1}^nk^2+3\sum_{k=1}^nk+n\end{aligned}\]</span></p><p><span class="math display">\[\begin{aligned}=3\sum_{k=1}^nk^2+\frac{3n(n+1)}{2}+n\end{aligned}\]</span></p><p>整理后即为 <span class="math display">\[\begin{aligned}\sum_{k=1}^nk^2=\frac{n(n+1)(2n+1)}{6}\end{aligned}\]</span> 继续下去可得 <span class="math display">\[\begin{aligned}\sum_{k=1}^nk^3=[\frac{n(n+1)}{2}]^2\end{aligned}\]</span> 由此，伯努利得到了<span class="math inline">\(\sum_{k=0}^{n-1}k^m\)</span>的通项，如上文。</p><h2 id="一个优美的性质">一个优美的性质</h2><p>令公式中的<span class="math inline">\(n=1\)</span>可得 <span class="math display">\[\begin{aligned}0=\frac{1}{m+1}\sum_{k=0}^mC_{m+1}^kB_k\end{aligned}\]</span> 即 <span class="math display">\[\begin{aligned}\sum_{k=0}^mC_{m+1}^kB_k=0\end{aligned}\]</span></p><h2 id="证明咕咕咕">证明（咕咕咕）</h2><h3 id="方法1归纳法">方法1：归纳法</h3><h3 id="方法2生成函数">方法2：生成函数</h3>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组合数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
