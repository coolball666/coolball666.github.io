<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>食用说明</title>
    <link href="/2050/10/17/%E9%A3%9F%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <url>/2050/10/17/%E9%A3%9F%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="本站食用说明">本站食用说明</h1><h2 id="这是大蒟蒻coolball的个人博客">这是大蒟蒻CoolBall的个人博客</h2><ol type="1"><li>这里会发一些学习笔记（比如算法、数据结构、数分）</li><li>还会有一些日常（比如本篇）</li><li>本站才刚创建，功能会慢慢补充上去，“慢慢”（数科院实在是太忙了）</li><li>欢迎各位dalao，julao，奆佬和神斧正（评论功能之后开呜呜）</li><li>禁止讨论敏感话题（dddd）</li></ol><h2 id="更新说明">更新说明</h2><p>不定期更新，看心情（主要是太菜了）</p><h2 id="希望写博客可以让我学到更多和认识更多神仙">希望写博客可以让我学到更多和认识更多神仙！</h2><h2 id="感谢enderturtle龟龟神仙让我有了建博客的想法并且给我提供帮助">感谢Enderturtle龟龟神仙让我有了建博客的想法并且给我提供帮助！</h2><p>无了，有啥之后再补充吧（</p>]]></content>
    
    
    <categories>
      
      <category>进站必读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从积性函数到莫比乌斯反演</title>
    <link href="/2022/04/01/%E4%BB%8E%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0%E5%88%B0%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    <url>/2022/04/01/%E4%BB%8E%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0%E5%88%B0%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/</url>
    
    <content type="html"><![CDATA[<h1 id="从积性函数到莫比乌斯反演">从积性函数到莫比乌斯反演</h1><p>呜呜呜，为了数论课不做大牢，学数论！</p><h2 id="简单介绍">简单介绍</h2><h3 id="数论函数">数论函数</h3><p>数论函数，简单来说就是定义域是<span class="math inline">\(\mathbb{N^{*}}\)</span>的函数，可以视为一个数列</p><h3 id="积性函数">积性函数</h3><h4 id="定义">定义</h4><p>积性函数是一类特殊的数论函数，它满足以下性质 <span class="math display">\[f(1) = 1. \ \forall i, j\in\mathbb{N^{*}},gcd(i,j)=1: f(i*j)=f(i)*f(j)\]</span> 特别的，若积性函数被称为完全积性函数若它满足以下性质 <span class="math display">\[\forall i,j\in \mathbb{N^{*}}:f(i*j)=f(i)*f(j)\]</span></p><h4 id="性质">性质</h4><p>设<span class="math inline">\(f\)</span>,<span class="math inline">\(g\)</span>为积性函数，则 <span class="math display">\[h(x)=f(x)*g(x),\ h(x)=f(x^{p}),\ h(x)=f^{p}(x),\ h(x)=\sum_{d|x}f(d)g(\frac{x}{d})\]</span> 也为积性函数</p><p>特别的，根据唯一分解定理，设<span class="math inline">\(x=\prod p_i^{k_i}\)</span>，若<span class="math inline">\(F\)</span>为积性函数，则有 <span class="math display">\[F(x)=\prod F(p_i^{k_i})\]</span> 若<span class="math inline">\(F\)</span>为完全积性函数，则有 <span class="math display">\[F(x)=\prod F^{k_i}(p_i)\]</span></p><h4 id="例子">例子</h4><p>恒等函数<span class="math inline">\(id(n) \equiv n\)</span></p><p>单位函数<span class="math inline">\(\epsilon (n)=[n=1]\)</span></p><p>常数函数<span class="math inline">\(1(n)\equiv 1\)</span></p><p>因子和函数<span class="math inline">\(\delta(n)=\sum_{d|n}d\)</span></p><p>因子个数函数<span class="math inline">\(\tau(n)=\sum_{d|n}1\)</span></p><p>一般的，除数函数<span class="math inline">\(\sigma_k(n)=\sum_{d|n}d^k\)</span></p><p>欧拉函数<span class="math inline">\(\phi(n)=\sum_{i=1}^n[gcd(i,n)=1]\)</span>，即<span class="math inline">\(n\)</span>的与<span class="math inline">\(n\)</span>互质的因数的个数</p><p>莫比乌斯函数，其中<span class="math inline">\(n=\prod_{i=1}^r p_i^{k_i}\)</span> <span class="math display">\[\mu(n)=\begin{cases}1,n=1\\0,\exists i, s.t.k_i&gt;=2\\(-1)^r,otherwise\end{cases}\]</span> 值得指出的是，上述前三个函数为完全积性函数</p><h3 id="dirichlet卷积"><span class="math inline">\(Dirichlet\)</span>卷积</h3><h4 id="定义-1">定义</h4><p>设<span class="math inline">\(f\)</span>和<span class="math inline">\(g\)</span>为数论函数，则两者的<span class="math inline">\(Dirichlet\)</span>卷积<span class="math inline">\(f*g\)</span>定义如下 <span class="math display">\[f*g(n):=\sum_{d|n}f(d)g(\frac{n}{d})\]</span></p><h4 id="性质-1">性质</h4><p><span class="math inline">\(f\)</span>,<span class="math inline">\(g\)</span>,<span class="math inline">\(h\)</span>为数论函数</p><h5 id="单位元存在性">单位元存在性</h5><p><span class="math inline">\(\forall f, \exists \epsilon\)</span>，有<span class="math inline">\(f*\epsilon \equiv f\)</span></p><h5 id="逆元唯一性">逆元唯一性</h5><p>若<span class="math inline">\(\exists g, s.t.f*g\equiv\epsilon\)</span>，则称<span class="math inline">\(g\)</span>为<span class="math inline">\(f\)</span>的逆元，事实上，逆元唯一</p><h5 id="交换律">交换律</h5><p><span class="math inline">\(f*g=g*f\)</span></p><h5 id="结合律">结合律</h5><p><span class="math inline">\(f*(g*h)=(f*g)*h\)</span></p><h5 id="分配律">分配律</h5><p><span class="math inline">\(f*(g+h)=f*g+f*h\)</span></p><h5 id="恒等关系">恒等关系</h5><p><span class="math inline">\(f=g\iff f*h=g*h\)</span></p><h4 id="重要结论">重要结论</h4><p><strong>1.积性函数的卷积仍为积性函数</strong></p><p><strong>2.积性函数的逆元也为积性函数</strong></p><h4 id="例子-1">例子</h4><p>1.<span class="math inline">\(\epsilon=\mu*1\)</span></p><p>2.<span class="math inline">\(\tau=1*1\)</span></p><p>3.<span class="math inline">\(\delta=id*1\)</span></p><p><strong>4.<span class="math inline">\(\phi=\mu*1\)</span></strong></p><h2 id="数论分块">数论分块</h2><p>数论分块可以用于快速求解带<strong>向下取整</strong>（显然也有整除）的和式，时间复杂度可以达到<span class="math inline">\(O(\sqrt n)\)</span></p><h3 id="两个结论">两个结论</h3><p>1.<span class="math inline">\(\forall a,b,c\in\mathbb{Z}, \lfloor\frac{\lfloor\frac{a}{b}\rfloor}{c}\rfloor=\lfloor\frac{a}{bc}\rfloor\)</span></p><p>2.<span class="math inline">\(\forall n\in\mathbb{N^*},|V|=\{\lfloor\frac{n}{d}\rfloor|\forall d, 1 \le d\le n\}| \le 2\lfloor\sqrt{n}\rfloor\)</span></p><p>所以可以枚举每个整数<span class="math inline">\(d\)</span>对应的<span class="math inline">\(i\)</span>的区间，来分块计算各个小区间对应的答案，最后相加就行，实现如下</p><h3 id="实现">实现</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">ll <span class="hljs-title">partitioning</span><span class="hljs-params">(ll n)</span> </span>&#123;<br>    ll ans = <span class="hljs-number">0</span>;<br>    ll l, r;<br>    <span class="hljs-keyword">for</span>(l = <span class="hljs-number">1</span>; l &lt;= n; l++) &#123;<br>        r = n / (n / l);<br>        ans += <span class="hljs-number">1LL</span> * (r - l + <span class="hljs-number">1</span>) * <span class="hljs-built_in">expression</span>(l);\\expression is the formula that is to be solved<br>        l = r;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="莫比乌斯反演">莫比乌斯反演</h2><p>来到了，高一集训时的噩梦，<span class="math inline">\(cjq\)</span>大仙的解方程猜测<span class="math inline">\(\mu\)</span>函数现场，四年来念念不忘的<strong>Mobius Inversion</strong></p><h3 id="mu函数的补充"><span class="math inline">\(\mu\)</span>函数的补充</h3><p><span class="math inline">\([gcd(i,j)=1]=\sum_{d|gcd(i,j)} {\mu(d)}\)</span></p><p>即<span class="math inline">\([gcd(i,j)=1]=\epsilon *gcd(i,j)\)</span></p><p>显然，如果<span class="math inline">\(gcd(i,j)=1\)</span>，那么d只能取<span class="math inline">\(1\)</span>，故和式为<span class="math inline">\(1\)</span>；若不然，<span class="math inline">\(gcd(i,j)\)</span>的因子总是成对出现，故可取到的<span class="math inline">\(\mu\)</span>中<span class="math inline">\((-1)^r\)</span>的<span class="math inline">\(r\)</span>总是连续的<span class="math inline">\(1-2n\)</span>，故结果为<span class="math inline">\(0\)</span></p><h3 id="线性筛">线性筛</h3><p>线性筛可以用于求绝大部分积性函数（其实我也不知道有什么不能求的），区别只在于在线性筛过程中对函数值的处理计算</p><p>对于<span class="math inline">\(\mu\)</span>函数，实现如下</p><h4 id="实现-1">实现</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getMu</span><span class="hljs-params">()</span> </span>&#123;<br>    mu[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    inp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= maxn; i++) &#123;<br>        <span class="hljs-keyword">if</span>(!inp[i]) prime[++tot] = i, mu[i] = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= tot &amp;&amp; i * prime[j] &lt;= maxn; j++) &#123;<br>            inp[i * prime[j]] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(i % prime[j] == <span class="hljs-number">0</span>) &#123;<br>                mu[i * p[j]] = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            mu[i * p[j]] = -mu[i];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="结论">结论</h3><p><span class="math inline">\(f\)</span>和<span class="math inline">\(g\)</span>为两个数论函数，若 <span class="math display">\[f(n)=\sum_{d|n}g(d)\]</span> 则有 <span class="math display">\[g(n)=\sum_{d|n}\mu(d)f(\frac{n}{d})\]</span> <span class="math inline">\(f\)</span>称为<span class="math inline">\(g\)</span>的莫比乌斯变换，<span class="math inline">\(而g\)</span>称为<span class="math inline">\(f\)</span>的莫比乌斯反演，可以看出，<span class="math inline">\(f = g*1\)</span></p><p>那么，如果遇到 <span class="math display">\[\sum_{i=1}^n\sum_{j=1}^m [gcd(i,j)=1]\]</span> 就可以转化为 <span class="math display">\[\sum_{i=1}^n\sum_{j=1}^m\sum_{d|gcd(i,j)}{\mu(d)}\]</span> 改变求和顺序，可以得到 <span class="math display">\[\sum_{d=1}\mu(d)\sum_{i = 1}^n[d|i]\sum_{j=1}^m[d|j]\]</span> 显然后面两个求和号可以直接得出结果，故 <span class="math display">\[\sum_{i=1}^n\sum_{j=1}^m [gcd(i,j)=1]=\sum_{d=1}^{min(n,m)}\mu(d)\lfloor\frac{n}{d}\rfloor\lfloor\frac{m}{d}\rfloor\]</span> 直接使用数论分块解决即可</p><h3 id="实现-2">实现</h3><p>以<a href="https://www.luogu.com.cn/problem/P2522">[HAOI2011] Problem b</a>为例</p><p>推导与上述无异，再使用二维容斥即可解决问题</p><p>即计算 <span class="math display">\[\sum_{d=1}^{min(\lfloor\frac{n}{k}\rfloor,\lfloor\frac{m}{k}\rfloor)}\mu(d)\lfloor\frac{n}{kd}\rfloor\lfloor\frac{m}{kd}\rfloor\]</span> 令<span class="math inline">\(n=b,m=d;n=b,m=c-1;n=a-1,m=d;n=a-1,m=c-1\)</span>四种情况即可</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n, mu[maxn], prime[maxn], tot = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">bool</span> inp[maxn];<br><span class="hljs-keyword">int</span> a, b, c, d, k;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//get prefix of mu</span><br>    mu[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>, inp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">2</span>, maxn) &#123;<br>        <span class="hljs-keyword">if</span>(!inp[i]) &#123;<br>            prime[++tot] = i;<br>            mu[i] = <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= tot &amp;&amp; i * prime[j] &lt;= maxn; j++) &#123;<br>            inp[i * prime[j]] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(i % prime[j] == <span class="hljs-number">0</span>) &#123;<br>                mu[i * prime[j]] = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            mu[i * prime[j]] = -mu[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, maxn) mu[i] += mu[i - <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">cal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123; <span class="hljs-comment">//calculate the sum</span><br>    ll ans = <span class="hljs-number">0</span>;<br>    ll l, r;<br>    <span class="hljs-keyword">for</span>(l = <span class="hljs-number">1</span>; l &lt;= <span class="hljs-built_in">min</span>(n, m); l++) &#123;<br>        r = <span class="hljs-built_in">min</span>(n / (n / l), m / (m / l));<br>        ans += <span class="hljs-number">1LL</span> * (mu[r] - mu[l - <span class="hljs-number">1</span>]) * (n / l) * (m / l);<br>        l = r;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    a = <span class="hljs-built_in">read</span>(), b = <span class="hljs-built_in">read</span>(), c = <span class="hljs-built_in">read</span>(), d = <span class="hljs-built_in">read</span>(), k = <span class="hljs-built_in">read</span>();<br>    ll res = <span class="hljs-built_in">cal</span>(b / k, d / k) - <span class="hljs-built_in">cal</span>((a - <span class="hljs-number">1</span>) / k, d / k) - <span class="hljs-built_in">cal</span>(b / k, (c - <span class="hljs-number">1</span>) / k) + <span class="hljs-built_in">cal</span>((a - <span class="hljs-number">1</span>) / k, (c - <span class="hljs-number">1</span>) / k);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, res);<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>莫比乌斯反演</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可持久化线段树</title>
    <link href="/2022/03/06/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <url>/2022/03/06/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="可持久化线段树学习笔记">可持久化线段树学习笔记</h1><h2 id="前言">前言</h2><p>之前写到一题区间第k大相关的题，可惜不会主席树，就现在学了一学</p><h2 id="前置知识">前置知识</h2><p>1、线段树</p><p>2、离散化</p><h2 id="正式开始">正式开始</h2><p>可持久化线段树是维护历史版本的一个数据结构</p><p>要查询区间第k大，自然就可以想到<strong>维护<span class="math inline">\(1-i\)</span>在这个区间<span class="math inline">\([l,r]\)</span>里个数</strong></p><p>为了简化问题，可以率<strong>先考虑区间<span class="math inline">\([1,k]\)</span>里的数字</strong>，随后运用<strong>前缀和</strong>解决问题</p><p>但如果每次操作都保存一棵线段树，这样子空间肯定会爆掉（</p><p>所以我们用更为优雅的方法记录历史版本</p><p>观察发现，每次操作只会更新线段树上的一条链，所以我们可以<strong>只保存一条链</strong>，并且跟原来的一整棵线段树的一部分节点构建父子关系</p><p>这样一来，就可以大大降低空间的使用了</p><p>下面来几张图解释一下建树的过程</p><p>我们以<span class="math inline">\([25957,6405,15770,26287,26465]\)</span>为例，先对他离散化，得到<span class="math inline">\([3,1,2,4,5]\)</span></p><p>先建一棵空树</p><figure><img src="/2022/03/06/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/1.PNG" alt="1"><figcaption aria-hidden="true">1</figcaption></figure><p>然后添加第一个节点，也就是离散化后的<span class="math inline">\(&#39;3&#39;\)</span></p><figure><img src="/2022/03/06/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/2.PNG" alt="2"><figcaption aria-hidden="true">2</figcaption></figure><p>然后以此类推，最后的树长成这样</p><figure><img src="/2022/03/06/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/6.PNG" alt="6"><figcaption aria-hidden="true">6</figcaption></figure><p>不同的颜色表示了不同的操作次数</p><p>显然，我们无法使用跟普通线段树类似的堆的方法存储节点的左右孩子，所以需要另外开两个数组存储</p><p>查询时，我们只需要对左子树做差，得到一个值<span class="math inline">\(x\)</span>，如果结果大于我们需要的<span class="math inline">\(k\)</span>，那就从右子树继续查询，但查询的值得减去<span class="math inline">\(x\)</span>；如果小于，就继续从左子树查询</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ql, <span class="hljs-keyword">int</span> qr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>, x = sum[ls[qr]] - sum[ls[ql]];<br>    <span class="hljs-keyword">if</span>(l == r) <span class="hljs-keyword">return</span> l;<br>    <span class="hljs-keyword">if</span>(k &lt;= x) <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(ls[ql], ls[qr], l, mid, k);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(rs[ql], rs[qr], mid + <span class="hljs-number">1</span>, r, k - x);<br></code></pre></div></td></tr></table></figure><p>为了实现这个数据结构，我们还需要一个数组<span class="math inline">\(rt\)</span>来存储每一棵线段树的根节点的信息，也就是上图中最上面的一层。</p><p>至此，我们已经悟了主席树是个什么东西和大概怎么实现，细节部分会在下面实现的代码中呈现</p><h2 id="实现">实现</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> LOG = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">int</span> n, m, len, tot;<br><span class="hljs-keyword">int</span> a[maxn], ind[maxn];<br><span class="hljs-keyword">int</span> sum[maxn * LOG], rt[maxn], ls[maxn * LOG], rs[maxn * LOG];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getid</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;val)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">lower_bound</span>(ind + <span class="hljs-number">1</span>, ind + <span class="hljs-number">1</span> + len, val) - ind;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> root = ++tot;<br>    <span class="hljs-keyword">if</span>(l == r) <span class="hljs-keyword">return</span> root;<br>    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>    ls[root] = <span class="hljs-built_in">build</span>(l, mid);<br>    rs[root] = <span class="hljs-built_in">build</span>(mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> root)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> dir = ++tot;<br>    ls[dir] = ls[root], rs[dir] = rs[root], sum[dir] = sum[root] + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(l == r) <span class="hljs-keyword">return</span> dir;<br>    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(k &lt;= mid) ls[dir] = <span class="hljs-built_in">update</span>(k, l, mid, ls[dir]);<br>    <span class="hljs-keyword">else</span> rs[dir] = <span class="hljs-built_in">update</span>(k, mid + <span class="hljs-number">1</span>, r, rs[dir]);<br>    <span class="hljs-keyword">return</span> dir;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ql, <span class="hljs-keyword">int</span> qr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>, x = sum[ls[qr]] - sum[ls[ql]];<br>    <span class="hljs-keyword">if</span>(l == r) <span class="hljs-keyword">return</span> l;<br>    <span class="hljs-keyword">if</span>(k &lt;= x) <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(ls[ql], ls[qr], l, mid, k);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(rs[ql], rs[qr], mid + <span class="hljs-number">1</span>, r, k - x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    n = <span class="hljs-built_in">read</span>(), m = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) a[i] = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">memcpy</span>(ind, a, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ind));<br>    <span class="hljs-built_in">sort</span>(ind + <span class="hljs-number">1</span>, ind + <span class="hljs-number">1</span> + n);<br>    len = <span class="hljs-built_in">unique</span>(ind + <span class="hljs-number">1</span>, ind + <span class="hljs-number">1</span> + n) - ind - <span class="hljs-number">1</span>;<br>    rt[<span class="hljs-number">0</span>] = <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, len);<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        rt[i] = <span class="hljs-built_in">update</span>(<span class="hljs-built_in">getid</span>(a[i]), <span class="hljs-number">1</span>, len, rt[i - <span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, m) &#123;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-built_in">read</span>(), r = <span class="hljs-built_in">read</span>(), k = <span class="hljs-built_in">read</span>();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ind[<span class="hljs-built_in">query</span>(rt[l - <span class="hljs-number">1</span>], rt[r], <span class="hljs-number">1</span>, len, k)]);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="空间分析">空间分析</h2><p>我们一开始得先开一棵线段树，由于是动态开点，所需空间是<span class="math inline">\(2n-1\)</span>，在后续的更新操作中，每次操作最多需要<span class="math inline">\(\lceil logn\rceil +1\)</span>个点</p><p>综上，我们总共需要<span class="math inline">\(2n-1+n(\lceil logn\rceil +1)\)</span>个点，瞎估估就是<span class="math inline">\(n(3+ \lceil logn\rceil)\)</span>个节点</p><h2 id="时间分析">时间分析</h2><p>我们开一棵空树需要的时间是<span class="math inline">\(O(logn)\)</span>，每次更新和查询的时间开销也是<span class="math inline">\(O(logn)\)</span>的，对于m次查询，总共的时间复杂度就是<span class="math inline">\(O(mlogn)\)</span>的</p><p>还是非常优秀的</p><h2 id="写在最后">写在最后</h2><p>上面是我学习完主席树后的一点笔记，如果您发现了任何问题，请在下面评论直接告诉我（评论期望近期开放）</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模板</tag>
      
      <tag>可持久化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DeterminantCalculator</title>
    <link href="/2021/11/05/DeterminantCalculator/"/>
    <url>/2021/11/05/DeterminantCalculator/</url>
    
    <content type="html"><![CDATA[<p>行列式太难算了</p><p>网上计算器也没过程</p><p>整了一个</p><p>非常丑</p><p>但无所谓了（</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxm 6005</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxn 1010</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inf 2147483647</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxw 13000</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i, a, b) for(int i = a; i &lt;= b; i++)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> loop(i, a, b) for(int i = a; i &gt;= b; i--)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> sqr(x) ((x) * (x))</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    ll s = <span class="hljs-number">0</span>, w = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">char</span> ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;-&#x27;</span>) w = <span class="hljs-number">-1</span>; ch = <span class="hljs-built_in">getchar</span>();&#125;<br>    <span class="hljs-keyword">while</span>(ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;s = s * <span class="hljs-number">10</span> + ch - <span class="hljs-string">&#x27;0&#x27;</span>; ch = <span class="hljs-built_in">getchar</span>();&#125;<br>    <span class="hljs-keyword">return</span> s * w;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* ============================================================================</span><br><span class="hljs-comment">@Author:      Cool_Ball</span><br><span class="hljs-comment">@DateTime:    2021-11-04 21:03:38</span><br><span class="hljs-comment">* ============================================================================</span><br><span class="hljs-comment">*/</span><br><br>ll n;<br><br><span class="hljs-comment">//----------fraction start----------//</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">frac</span> &#123;</span><br>    ll up, down;<br>&#125;;<br><br><span class="hljs-function">ll <span class="hljs-title">gcd</span><span class="hljs-params">(ll a, ll b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">gcd</span>(b, a % b);<br>&#125;<br><br><span class="hljs-function">frac <span class="hljs-title">add</span><span class="hljs-params">(frac a, frac b)</span> </span>&#123;<br>    ll tmp1 = a.down * b.down, tmp2 = a.up * b.down + b.up * a.down;<br>    ll g = <span class="hljs-built_in">gcd</span>(tmp1, tmp2);<br>    tmp1 /= g, tmp2 /= g;<br>    <span class="hljs-keyword">return</span> frac&#123;tmp2, tmp1&#125;;<br>&#125;<br><br><span class="hljs-function">frac <span class="hljs-title">subt</span><span class="hljs-params">(frac a, frac b)</span> </span>&#123;<br>    ll tmp1 = a.down * b.down, tmp2 = a.up * b.down - b.up * a.down;<br>    ll g = <span class="hljs-built_in">gcd</span>(tmp1, tmp2);<br>    tmp1 /= g, tmp2 /= g;<br>    <span class="hljs-keyword">if</span>(tmp1 &lt; <span class="hljs-number">0</span>) &#123;<br>        tmp1 = <span class="hljs-built_in">abs</span>(tmp1);<br>        tmp2 = -tmp2;<br>    &#125;<br>    <span class="hljs-keyword">return</span> frac&#123;tmp2, tmp1&#125;;<br>&#125;<br><br><span class="hljs-function">frac <span class="hljs-title">mul</span><span class="hljs-params">(frac a, frac b)</span> </span>&#123;<br>    ll tmp1 = a.down * b.down, tmp2 = a.up * b.up;<br>    ll g = <span class="hljs-built_in">gcd</span>(tmp1, tmp2);<br>    tmp1 /= g, tmp2 /= g;<br>    <span class="hljs-keyword">return</span> frac&#123;tmp2, tmp1&#125;;<br>&#125;<br><br><span class="hljs-function">frac <span class="hljs-title">div</span><span class="hljs-params">(frac a, frac b)</span> </span>&#123;<br>    ll tmp1 = a.down * b.up, tmp2 = a.up * b.down;<br>    ll g = <span class="hljs-built_in">gcd</span>(tmp1, tmp2);<br>    tmp1 /= g, tmp2 /= g;<br>    <span class="hljs-keyword">return</span> frac&#123;tmp2, tmp1&#125;;<br>&#125;<br><span class="hljs-comment">//----------fraction end----------//</span><br><br><br><span class="hljs-comment">//----------Guass Elimination start----------//</span><br>frac A[maxn][maxn];<br>ll exc = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Guass</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        <span class="hljs-comment">//find largest pivot</span><br>        ll maxx = i;<br>        <span class="hljs-built_in">rep</span>(j, i + <span class="hljs-number">1</span>, n) &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(A[j][i].up * A[maxx][i].down) &gt; <span class="hljs-built_in">abs</span>(A[maxx][i].up * A[j][i].down)) &#123;<br>                maxx = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//row exhange</span><br>        <span class="hljs-keyword">if</span>(maxx != i) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;Switch the &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;-th row with the &quot;</span> &lt;&lt; maxx &lt;&lt; <span class="hljs-string">&quot;-th row&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-built_in">rep</span>(j, <span class="hljs-number">1</span>, n) &#123;<br>                <span class="hljs-built_in">swap</span>(A[i][j], A[maxx][j]);<br>            &#125;<br>            exc++;<br>            <span class="hljs-built_in">rep</span>(o, <span class="hljs-number">1</span>, n) &#123;<br>                <span class="hljs-built_in">rep</span>(p, <span class="hljs-number">1</span>, n) &#123;<br>                    cout &lt;&lt; A[o][p].up;<br>                    <span class="hljs-keyword">if</span>(A[o][p].down != <span class="hljs-number">1</span>) cout &lt;&lt; <span class="hljs-string">&quot;/&quot;</span> &lt;&lt; A[o][p].down;<br>                    cout &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>                &#125;<br>                cout &lt;&lt; endl;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//Guass eliminated to upper triangular matrix</span><br>        <span class="hljs-built_in">rep</span>(j, i + <span class="hljs-number">1</span>, n) &#123;<br>            frac tmp = <span class="hljs-built_in">div</span>(A[j][i] ,A[i][i]);<br>            cout &lt;&lt; <span class="hljs-string">&quot;Subtract the &quot;</span> &lt;&lt; j &lt;&lt; <span class="hljs-string">&quot;-th row with &quot;</span> &lt;&lt; tmp.up &lt;&lt; <span class="hljs-string">&quot;/&quot;</span> &lt;&lt; tmp.down &lt;&lt; <span class="hljs-string">&quot; times of the &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;-th row.&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-built_in">rep</span>(k, i , n) &#123;<br>                A[j][k] = <span class="hljs-built_in">subt</span>(A[j][k], <span class="hljs-built_in">mul</span>(A[i][k], tmp));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i &lt; n) &#123;<br>            <span class="hljs-built_in">rep</span>(o, <span class="hljs-number">1</span>, n) &#123;<br>                <span class="hljs-built_in">rep</span>(p, <span class="hljs-number">1</span>, n) &#123;<br>                    cout &lt;&lt; A[o][p].up;<br>                    <span class="hljs-keyword">if</span>(A[o][p].down != <span class="hljs-number">1</span>) cout &lt;&lt; <span class="hljs-string">&quot;/&quot;</span> &lt;&lt; A[o][p].down;<br>                    cout &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>                &#125;<br>                cout &lt;&lt; endl;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//output the determianat of the martix</span><br>    frac ans = frac&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        ans = <span class="hljs-built_in">mul</span>(ans, A[i][i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The determinant of the matrix is:\n&quot;</span>);<br>    <span class="hljs-keyword">if</span>(exc % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &amp;&amp; ans.up != <span class="hljs-number">0</span>) cout &lt;&lt; <span class="hljs-string">&quot;-&quot;</span>;<br>    cout &lt;&lt; ans.up;<br>    <span class="hljs-keyword">if</span>(ans.down != <span class="hljs-number">1</span>) cout &lt;&lt; <span class="hljs-string">&quot;/&quot;</span> &lt;&lt; ans.down &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//----------Guass Elimination end----------//</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inp</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Please input the matrix(integer or fraction)\n&quot;</span>);<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        <span class="hljs-built_in">rep</span>(j, <span class="hljs-number">1</span>, n) &#123;<br>            <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>;<br>            string s;<br>            cin &gt;&gt; s;<br>            ll num = <span class="hljs-number">0</span>, w = <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">rep</span>(k, <span class="hljs-number">0</span>, s.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">if</span>(s[k] == <span class="hljs-string">&#x27;/&#x27;</span>) &#123;<br>                    flag = <span class="hljs-literal">true</span>;<br>                    A[i][j].up = w * num;<br>                    w = <span class="hljs-number">1</span>, num = <span class="hljs-number">0</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(s[k] == <span class="hljs-string">&#x27;-&#x27;</span>) w = <span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">if</span>(s[k] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[k] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) num = num * <span class="hljs-number">10</span> + s[k] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag) A[i][j].down = w * num;<br>            <span class="hljs-keyword">else</span> &#123;<br>                A[i][j].up = w * num;<br>                A[i][j].down = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Please input the matrix size(n*n)\n&quot;</span>);<br>    n = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">inp</span>();<br>    <span class="hljs-built_in">Guass</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>行列式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拉格朗日插值法</title>
    <link href="/2021/10/21/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E6%B3%95/"/>
    <url>/2021/10/21/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="中国剩余定理和lagrange插值法">中国剩余定理和Lagrange插值法</h1><h2 id="引言">引言</h2><p>很巧，高代课讲到了Lagrange插值法，凭着“上课听不明白只好下课自己搞”的意志，我学学证明顺带来写个板子。</p><h2 id="前置知识中国剩余定理crt">前置知识：中国剩余定理（CRT）</h2><p>中国剩余定理是用来求解形如 <span class="math display">\[\begin{cases}x &amp; \equiv  a_1 (mod \quad m_1) \\x &amp; \equiv  a_2 (mod \quad m_2) \\&amp;...... \\x &amp; \equiv  a_k (mod \quad m_k)\end{cases}\]</span> 的线性同余方程组的解的。其中，<span class="math inline">\(\forall i\neq j \quad (a_i, a_j)=1\)</span>，我们需要找出最小的非负整数解<span class="math inline">\(x\)</span>。</p><h3 id="解法">解法</h3><p>设<span class="math inline">\(M=\prod_{i=0}^k m_i\)</span>,<span class="math inline">\(M_i=\frac{M}{m_i}\)</span>,<span class="math inline">\(M_iT_i \equiv 1(mod \ m_i)\)</span>，其中<span class="math inline">\(1\leq i,j \leq n\)</span>。</p><p>故可以构造一个解<span class="math inline">\(x=\sum_{i=1}^na_iM_it_i\)</span></p><p>由此，可以求出任意解<span class="math inline">\(x_0=x+k*M\)</span></p><p><strong>最小正整数解<span class="math inline">\(X\)</span></strong>即为<span class="math inline">\(x_0\%M\)</span></p><h3 id="证明">证明</h3><p>显然，在第<span class="math inline">\(i\)</span>个同余方程里，<span class="math inline">\(a_jM_jt_j \equiv 0(mod \ m_i)\)</span></p><p><span class="math inline">\(a_iM_it_i \equiv a_i(mod \ m_i)\)</span></p><p>所以<span class="math inline">\(\forall i,X \equiv a_i (mod \ m_i)\)</span>，满足题意。</p><h3 id="乘法逆元">乘法逆元</h3><p>若<span class="math inline">\(a*a^{-1} \equiv 1 (mod \ p)\)</span>，则称<span class="math inline">\(a^{-1}\)</span>是<span class="math inline">\(a\)</span>在<span class="math inline">\(mod \ p\)</span>意义下的逆元。</p><p>用扩展欧几里得<span class="math inline">\((exgcd)\)</span>来求解</p><p>过程如下：</p><p><span class="math display">\[因为a*x+b*y=(a, b)\\且b*x&#39;+(a\%b)*y&#39;=(b,a\%b)\\a\%b=a-\lfloor\frac{a}{b}\rfloor*b\]</span></p><p><span class="math display">\[有a*y&#39;+b*(x&#39;-\lfloor\frac{a}{b}\rfloor*y&#39;)=(a,b)\\故x=y&#39;,y=(x&#39;-\lfloor\frac{a}{b}\rfloor*y&#39;)\]</span></p><p>显然，<span class="math inline">\((M_i, m_i)=1\)</span>，故令<span class="math inline">\(a=M_i, b=m_i\)</span>，则<span class="math inline">\(M_ix+m_iy=1\)</span>，故<span class="math inline">\(M_ix=1-m_iy\)</span>，可得<span class="math inline">\(x\)</span>为<span class="math inline">\(M_i\)</span>在<span class="math inline">\(mod\ m_i\)</span>下的逆元，即为题设所求。</p><h3 id="代码">代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">ll n, a[maxn], m[maxn], Mi[maxn], M = <span class="hljs-number">1</span>, X;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(ll a, ll b, ll &amp;x, ll &amp;y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>) &#123;x = <span class="hljs-number">1</span>; y = <span class="hljs-number">0</span>; <span class="hljs-keyword">return</span>;&#125;<br>    <span class="hljs-built_in">exgcd</span>(b, a % b, x, y);<br>    ll z = x;<br>    x = y, y = z - y * (a / b);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CRT</span><span class="hljs-params">()</span> </span>&#123;<br>    n = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        m[i] = <span class="hljs-built_in">read</span>(), a[i] = <span class="hljs-built_in">read</span>();<br>        M *= m[i];<br>    &#125;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        Mi[i] = M / m[i];<br>        ll x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">exgcd</span>(Mi[i], m[i], x, y);<br>        X += a[i] * Mi[i] * (x &lt; <span class="hljs-number">0</span> ? (x + m[i]):x);<br>    &#125;<br>    cout &lt;&lt; X % M &lt;&lt; endl;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="正片lagrange插值">正片：Lagrange插值</h2><h3 id="多项式储备知识多项式余数">多项式储备知识（多项式余数）</h3><p>已知多项式 <span class="math display">\[f(x)\in P[x],f(x)=\sum_{i=0}^{n}a_ix^i\]</span></p><p><span class="math display">\[故f(x)\%(x-\alpha)=\sum_{i=0}^{n}a_i\alpha^i\]</span></p><p>下证：</p><p>已知 <span class="math display">\[f(x)=\sum_{i=0}^{n}a_ix^i \\f(x)=\sum_{i=0}^{n}a_ix^i=\sum_{i=0}^{n}(x-\alpha+\alpha)^i=\sum_{i=0}^{n}a_i\sum_{j=0}^{i}{i \choose j}(x-\alpha)^j\alpha^{i-j}\]</span></p><p>可知，当<span class="math inline">\(j\neq0\)</span>时，该子项<span class="math inline">\(p\%(x-\alpha)=0\)</span>恒成立 故余数必为<span class="math inline">\(j=0\)</span>的项之和，即 <span class="math display">\[\begin{aligned}r(x)=\sum_{i=0}^{n}a_i\alpha^i\end{aligned}\]</span></p><h3 id="模意义下的推导过程">模意义下的推导过程</h3><p>由上述可以得到一个关于<span class="math inline">\(f(x)\)</span>的同余方程组，即 <span class="math display">\[\begin{cases}f(x) &amp; \equiv  y_1 (mod \ (x-x_1)) \\f(x) &amp; \equiv  y_2 (mod \ (x-x_2)) \\&amp;...... \\f(x) &amp; \equiv  y_n (mod \ (x-x_n))\end{cases}\]</span> 根据<strong>中国剩余定理</strong> <span class="math display">\[\begin{aligned}M=\prod_{i=1}^{n}(x-x_i),M_i=\frac{M}{x-x_i}=\prod_{j\neq i}(x-x_j)\end{aligned}\]</span> 得<span class="math inline">\(M_i\)</span>在<span class="math inline">\(mod(x-x_i)\)</span>意义下的逆元<span class="math inline">\(T_i\)</span>为 <span class="math display">\[\begin{aligned}M_i^{-1}=T_i=\prod_{j\neq i}\frac{1}{x_i-x_j}\end{aligned}\]</span> 故有 <span class="math display">\[\begin{aligned}f(x) \equiv \sum_{i=1}^{n}y_iM_iT_i\equiv \sum_{i=1}^{n}y_i\prod_{j\neq i}M_iT_i\equiv \sum_{i=1}^{n}y_i\prod_{j\neq i}\frac{x-x_i}{x_i-x_j} \quad mod(M)\end{aligned}\]</span></p><p>又<span class="math inline">\(f(x)\)</span>唯一，故 <span class="math display">\[\begin{aligned}f(x) = \sum_{i=1}^{n}y_i\prod_{j\neq i}\frac{x-x_i}{x_i-x_j}\end{aligned}\]</span> 即为Lagrange插值的表达式</p><h3 id="通常意义下的推导过程">通常意义下的推导过程</h3><p>已知<span class="math inline">\(f(x)\)</span>过<span class="math inline">\(n\)</span>个点<span class="math inline">\(P_1(x_1,y_1),P_2(x_2,y_2),...,P_n(x_n,y_n)\)</span>，以及其在<span class="math inline">\(x\)</span>轴上的投影<span class="math inline">\(P_i^{&#39;}(x_i,0)\)</span></p><p>考虑构造<span class="math inline">\(n\)</span>个函数<span class="math inline">\(F_i(x)\)</span>使得其过点， <span class="math display">\[\left\{\begin{aligned}&amp; P_j^{&#39;} \quad j\neq i \\&amp; P_i \quad j=i \end{aligned}\right.\]</span> 则可知所需函数<span class="math inline">\(f(x)=\sum_{i=1}^{n}F_i(x)\)</span>.</p><p>则可设<span class="math inline">\(F_i(x)=a\prod_{j\neq i}(x_i-x_j)\)</span>，将<span class="math inline">\(P_i\)</span>代入可得<span class="math inline">\(a=\frac{y_i}{\prod_{j\neq i}(x_i-x_j)}\)</span>，所以 <span class="math display">\[\begin{aligned}F_i(x)=y_i\prod_{j\neq i}\frac{x-x_j}{x_i-x_j}\end{aligned}\]</span> 由此导出<strong>Lagrange插值在通常意义下的公式</strong>，如下 <span class="math display">\[\begin{aligned}f(x)=\sum_{i=1}^{n}F_i(x)=\sum_{i=1}^{n}y_i\prod_{j\neq i}\frac{x-x_j}{x_i-x_j}\end{aligned}\]</span> 与上述<strong>在模意义下的Lagrange插值公式</strong>相同</p><h2 id="代码实现对xk时即需要求fk的值的代码">代码实现（对<span class="math inline">\(x=k\)</span>时，即需要求<span class="math inline">\(f(k)\)</span>的值的代码）</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> ll p = <span class="hljs-number">998244353</span>;<br>ll n, y[maxn], x[maxn], k;<br>ll ans, s1, s2;<br><br><span class="hljs-function">ll <span class="hljs-title">fastmod</span><span class="hljs-params">(ll a, ll k)</span> </span>&#123;<br>    ll base = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(k) &#123;<br>        <span class="hljs-keyword">if</span>(k &amp; <span class="hljs-number">1</span>) base = base * a % p;<br>        a = a * a % p;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> base % p;<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">inv</span><span class="hljs-params">(ll x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">fastmod</span>(x, p - <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Lagrange</span><span class="hljs-params">()</span> </span>&#123;<br>    n = <span class="hljs-built_in">read</span>(), k = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        x[i] = <span class="hljs-built_in">read</span>(), y[i] = <span class="hljs-built_in">read</span>();<br>    &#125;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        s1 = y[i] % p;<br>        s2 = <span class="hljs-number">1LL</span>;<br>        <span class="hljs-built_in">rep</span>(j, <span class="hljs-number">1</span>, n) &#123;<br>            <span class="hljs-keyword">if</span>(i != j) &#123;<br>                s1 = s1 * (k - x[j]) % p;<br>                s2 = s2 * (x[i]-x[j]) % p;<br>            &#125;<br>        &#125;<br>        ans += s1 * <span class="hljs-built_in">inv</span>(s2) % p;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, (ans % p + p) % p);<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>多项式</tag>
      
      <tag>扩展欧几里得</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>伯努利数</title>
    <link href="/2021/10/17/%E4%BC%AF%E5%8A%AA%E5%88%A9%E6%95%B0/"/>
    <url>/2021/10/17/%E4%BC%AF%E5%8A%AA%E5%88%A9%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="伯努利数">伯努利数</h1><p>今天看吉米多维奇的时候偶然看到伯努利数，一查oi-wiki上也有，就学了一下，就当第一篇博客了。（之后会写FFT和NTT，多项式求逆和多项式除法的）</p><h2 id="背景等幂求和">背景：等幂求和</h2><p><span class="math display">\[\begin{aligned}\sum_{k=0}^{n-1}k^m=\frac{1}{m+1}\sum_{k=0}^mC_{m+1}^kB_kn^{m+1-k}\end{aligned}\]</span></p><p>利用<span class="math inline">\((k+1)^2-k^2=2k+1\)</span>可得 <span class="math display">\[\begin{aligned}\sum_{k=1}^n[(k+1)^2-k^2]=\sum_{k=1}^n(2k+1)\end{aligned}\]</span> 整理后即为 <span class="math display">\[\begin{aligned}\sum_{k=1}^nk=\frac{n(n+1)}{2}\end{aligned}\]</span> 类似的，利用<span class="math inline">\((k+1)^3-k^3=3k^2+3k+1\)</span>可得 <span class="math display">\[\begin{aligned}\sum_{k=1}^n[(k+1)^3-k^3]=\sum_{k=1}^n(3k^2+3k+1)=3\sum_{k=1}^nk^2+3\sum_{k=1}^nk+n\end{aligned}\]</span></p><p><span class="math display">\[\begin{aligned}=3\sum_{k=1}^nk^2+\frac{3n(n+1)}{2}+n\end{aligned}\]</span></p><p>整理后即为 <span class="math display">\[\begin{aligned}\sum_{k=1}^nk^2=\frac{n(n+1)(2n+1)}{6}\end{aligned}\]</span> 继续下去可得 <span class="math display">\[\begin{aligned}\sum_{k=1}^nk^3=[\frac{n(n+1)}{2}]^2\end{aligned}\]</span> 由此，伯努利得到了<span class="math inline">\(\sum_{k=0}^{n-1}k^m\)</span>的通项，如上文。</p><h2 id="一个优美的性质">一个优美的性质</h2><p>令公式中的<span class="math inline">\(n=1\)</span>可得 <span class="math display">\[\begin{aligned}0=\frac{1}{m+1}\sum_{k=0}^mC_{m+1}^kB_k\end{aligned}\]</span> 即 <span class="math display">\[\begin{aligned}\sum_{k=0}^mC_{m+1}^kB_k=0\end{aligned}\]</span></p><h2 id="证明咕咕咕">证明（咕咕咕）</h2><h3 id="方法1归纳法">方法1：归纳法</h3><h3 id="方法2生成函数">方法2：生成函数</h3>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组合数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
